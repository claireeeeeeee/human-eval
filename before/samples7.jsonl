{"task_id": "HumanEval/151", "completion": "\ndef double_the_difference(lst):\n    if not isinstance(lst, list):\n        raise ValueError(\"Input must be a list\")\n    \n    sum_of_squares = 0\n    \n    for number in lst:\n        if isinstance(number, int) and number % 2 != 0:\n            sum_of_squares += number * number\n    \n    return sum_of_squares\n"}
{"task_id": "HumanEval/152", "completion": "\ndef compare(match_scores, match_guesses):\n    differences = []\n    \n    for i in range(len(match_scores)):\n        difference = abs(match_scores[i] - match_guesses[i])\n        differences.append(difference)\n    \n    return differences\n\nprint(compare([1,2,3,4,5,1],[1,2,3,4,2,-2]))\nprint(compare([0,5,0,0,0,4],[4,1,1,0,0,-2]))\nprint(compare([0,0,0,0],[0,0,0,0]))\nprint(compare([1,2,3,4,5],[5,4,3,2,1]))\n"}
{"task_id": "HumanEval/153", "completion": "def Strongest_Extension(class_name, extensions):"}
{"task_id": "HumanEval/154", "completion": "\ndef cycpattern_check(a, b):\n    if len(b) > len(a):\n        return False\n\n    if not b:\n        return True\n\n    rotations = [b]\n    for i in range(1, len(b)):\n        rotation = b[i:] + b[:i]\n\n        if rotation in a:\n            return True\n\n        if a.startswith(rotation) and a.endswith(rotation):\n            return True\n\n        rotations.append(rotation)\n\n    return False\n\nassert cycpattern_check(\"abcd\", \"abd\") == False\nassert cycpattern_check(\"hello\", \"ell\") == True\nassert cycpattern_check(\"whassup\", \"psus\") == False\nassert cycpattern_check(\"abab\", \"baa\") == True\nassert cycpattern_check(\"efef\", \"eeff\") == False\nassert cycpattern_check(\"himenss\", \"simen\") == True\n"}
{"task_id": "HumanEval/155", "completion": "def even_odd_count(num: int) -> Tuple[int, int]:"}
{"task_id": "HumanEval/156", "completion": "def int_to_mini_roman(number):"}
{"task_id": "HumanEval/157", "completion": "\ndef right_angle_triangle(a, b, c):\n    if a <= 0 or b <= 0 or c <= 0:\n        return False\n    if a + b <= c or b + c <= a or c + a <= b:\n        return False\n\n    sides = sorted([a, b, c])\n\n    if sides[0]**2 + sides[1]**2 == sides[2]**2:\n        return True\n    else:\n        return False\n\nassert right_angle_triangle(3, 4, 5) == True\nassert right_angle_triangle(5, 12, 13) == True\nassert right_angle_triangle(8, 15, 17) == True\nassert right_angle_triangle(1, 2, 3) == False\nassert right_angle_triangle(6, 8, 10) == True\nassert right_angle_triangle(7, 7, 7) == False\nassert right_angle_triangle(0, 4, 5) == False\n\nassert right_angle_triangle(5, 5, 5) == False\nassert right_angle_triangle(1, 1, 1) == False\nassert right_angle_triangle(3, 3, 4) == False\n"}
{"task_id": "HumanEval/158", "completion": "\ndef find_max(words):\n    \"\"\"\n    Finds the word in the given list that has the maximum number of unique characters.\n    If multiple words have the same maximum number of unique characters, the word \n    that comes first in lexicographical order is returned.\n    \"\"\"\n    if not words:\n        raise ValueError(\"List of words cannot be empty.\")\n\n    char_count = count_unique_chars(words)\n\n    max_count = max(char_count.values())\n    words_with_max_chars = get_words_with_max_chars(char_count, max_count)\n    \n    return words_with_max_chars[0]\n\ndef count_unique_chars(words):\n    \"\"\"\n    Counts the number of unique characters in each word of the given list.\n    Returns a dictionary with word as key and count as value.\n    \"\"\"\n    char_count = {}\n\n    for word in words:\n        unique_chars = set()\n\n        for char in word:\n            unique_chars.add(char)\n\n        char_count[word] = len(unique_chars)\n\n    return char_count\n\ndef get_words_with_max_chars(char_count, max_count):\n    \"\"\"\n    Filters the words with the maximum number of unique characters from the given dictionary.\n    Returns a sorted list of words with the maximum number of unique characters.\n    \"\"\"\n    words_with_max_chars = []\n\n    for word, count in char_count.items():\n        if count == max_count:\n            words_with_max_chars.append(word)\n\n    words_with_max_chars.sort()\n\n    return words_with_max_chars\n"}
{"task_id": "HumanEval/159", "completion": "def multiply_numbers(a, b):"}
{"task_id": "HumanEval/0", "completion": "\nfrom typing import List\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for i in range(len(numbers)):\n        for j in range(i+1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False\n\n# Unit Test\nassert has_close_elements([1.0, 2.0, 3.0], 0.5) == False\nassert has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) == True\n"}
{"task_id": "HumanEval/1", "completion": "def separate_paren_groups(paren_string: str) -> List[str]:"}
{"task_id": "HumanEval/2", "completion": "\ndef truncate_number(number: float) -> float:\n    try:\n        return number - int(number)\n    except Exception:\n        raise ValueError(\"Invalid input\")\n"}
{"task_id": "HumanEval/3", "completion": "def below_zero(operations: List[int]) -> bool:"}
{"task_id": "HumanEval/4", "completion": "def mean_absolute_deviation(numbers: List[float]) -> float:"}
{"task_id": "HumanEval/5", "completion": "\ndef intersperse(numbers, delimiter):\n    result = []\n    for i, num in enumerate(numbers):\n        result.append(num)\n        if i < len(numbers) - 1:\n            result.append(delimiter)\n    return result\n"}
{"task_id": "HumanEval/6", "completion": "\nfrom typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    if not paren_string:\n        return []\n\n    valid_chars = ['(', ')', ' ']\n    if not all(char in valid_chars for char in paren_string):\n        raise ValueError(\"Invalid input string. Only parentheses and spaces are allowed.\")\n\n    groups = paren_string.split(' ')\n    deepest_levels = []\n\n    for group in groups:\n        current_level = 0\n        deepest_level = 0\n\n        for char in group:\n            if char == '(':\n                current_level += 1\n            elif char == ')':\n                if current_level == 0:\n                    raise ValueError(\"Invalid input string. Unbalanced closing parenthesis.\")\n                current_level -= 1\n\n            deepest_level = max(deepest_level, current_level)\n\n        if current_level != 0:\n            raise ValueError(\"Invalid input string. Unbalanced opening parenthesis.\")\n\n        deepest_levels.append(deepest_level)\n\n    return deepest_levels\n\n# Unit test\nassert parse_nested_parens('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n"}
{"task_id": "HumanEval/7", "completion": "\nfrom typing import List\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    filtered_strings = []\n    \n    for string in strings:\n        if substring != '' and substring in string:\n            filtered_strings.append(string)\n    \n    return filtered_strings\n"}
{"task_id": "HumanEval/8", "completion": "\ndef sum_product(lst):\n    if len(lst) == 0:\n        return (0, 1)\n    \n    summation = 0\n    product = 1\n    \n    for num in lst:\n        summation += num\n        product *= num\n    \n    return (summation, product)\n\n# Test for an empty list\nprint(sum_product([])) # Output: (0, 1)\n\n# Test for a non-empty list\nprint(sum_product([1, 2, 3, 4])) # Output: (10, 24)\n"}
{"task_id": "HumanEval/9", "completion": "def rolling_max(numbers: List[int]) -> List[int]:"}
{"task_id": "HumanEval/10", "completion": "\ndef make_palindrome(string: str) -> str:\n    if not isinstance(string, str):\n        raise TypeError(\"Input must be a string\")\n    \n    if string == '':\n        return ''\n    \n    longest_suffix = ''\n    for i in range(len(string)-1, -1, -1):\n        suffix = string[i:]\n        if suffix == suffix[::-1]:\n            longest_suffix = suffix\n            break\n    \n    prefix = string[:i]\n    reversed_prefix = prefix[::-1]\n    \n    palindrome = reversed_prefix + string\n    return palindrome\n\n\n# Revised Unit Tests\nassert make_palindrome('') == ''\nassert make_palindrome('cat') == 'catac'\nassert make_palindrome('cata') == 'catac'\n\n# Additional Unit Tests\n\n# Test with special characters\nassert make_palindrome('!@$') == '!@$!'\n\n# Test with numbers\nassert make_palindrome('123') == '12321'\n\n# Test with whitespace\nassert make_palindrome('   ') == '     '\n\n# Test with longer input string\nassert make_palindrome('abcdefghijklmnopqrstuvwxyz') == 'abcdefghijklmnopqrstuvwxyzzyxwvutsrqponmlkjihgfedcba'\n\nprint(\"All test cases passed\")\n"}
{"task_id": "HumanEval/11", "completion": "\ndef string_xor(binary_string_1: str, binary_string_2: str) -> str:\n    \"\"\"\n    Compute the XOR operation on two binary strings.\n    \n    Parameters:\n    binary_string_1 (str): The first binary string.\n    binary_string_2 (str): The second binary string.\n    \n    Returns:\n    str: The resulting binary string after performing the XOR operation on the input strings.\n    \"\"\"\n    if len(binary_string_1) != len(binary_string_2):\n        raise ValueError(\"Input strings must have the same length.\")\n\n    result = []\n\n    for i in range(len(binary_string_1)):\n        if binary_string_1[i] == binary_string_2[i]:\n            result.append('0')\n        else:\n            result.append('1')\n\n    return ''.join(result)\n\n\ndef test_string_xor():\n    \"\"\"\n    Test case for the `string_xor` function.\n    \"\"\"\n    # Test case 1: XOR of '010' and '110' should be '100'\n    assert string_xor('010', '110') == '100'\n\n    # Test case 2: XOR of '1111' and '0000' should be '1111'\n    assert string_xor('1111', '0000') == '1111'\n\n    # Test case 3: XOR of '101010' and '010101' should be '111111'\n    assert string_xor('101010', '010101') == '111111'\n\n\nif __name__ == '__main__':\n    test_string_xor()\n"}
{"task_id": "HumanEval/12", "completion": "\nfrom typing import List, Optional\n\ndef longest(strings: List[str]) -> Optional[str]:\n    if not strings:\n        return None\n    \n    longest_str = \"\"\n    \n    for string in strings:\n        if len(string) > len(longest_str):\n            longest_str = string\n    \n    return longest_str\n\nassert longest([]) == None\nassert longest(['a', 'b', 'c']) == 'a' \nassert longest(['a', 'bb', 'ccc']) == 'ccc'\n"}
{"task_id": "HumanEval/13", "completion": "def calculate_gcd(x: int, y: int) -> int:\ndef get_gcd(a: int, b: int) -> int:\ndef test_gcd(self):"}
