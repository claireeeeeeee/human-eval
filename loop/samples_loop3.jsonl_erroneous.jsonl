{"task_id": "HumanEval/6", "completion": "def parse_nested_parens(s):\n    stack = []\n    max_depth = 0\n    current_depth = 0\n\n    for char in s:\n        if char == '(':\n            stack.append(char)\n            current_depth += 1\n            max_depth = max(max_depth, current_depth)\n        elif char == ')':\n            if not stack:\n                raise ValueError(\"Invalid input: Unmatched closing parenthesis\")\n            stack.pop()\n            current_depth -= 1\n\n    if stack:\n        raise ValueError(\"Invalid input: Unmatched opening parenthesis\")\n\n    return max_depth", "result": "failed:  (type: AssertionError)", "passed": false}
{"task_id": "HumanEval/10", "completion": "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"\n    if not string:\n        return ''\n\n    for i in range(len(string), -1, -1):\n        if is_palindrome(string[:i]):\n            return string + string[:i][::-1]", "result": "failed:  (type: AssertionError)", "passed": false}
{"task_id": "HumanEval/16", "completion": "def count_distinct_characters(input_string):\n    distinct_characters = set(input_string)\n    return len(distinct_characters)", "result": "failed:  (type: AssertionError)", "passed": false}
{"task_id": "HumanEval/26", "completion": "from typing import List\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    unique_elements = []\n    for num in numbers:\n        if num not in unique_elements:\n            unique_elements.append(num)\n    return unique_elements", "result": "failed:  (type: AssertionError)", "passed": false}
{"task_id": "HumanEval/32", "completion": "import math\n\n\ndef poly(xs: list, x: float):\n    \"\"\"\n    Evaluates polynomial with coefficients xs at point x.\n    return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n    \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n\ndef find_zero(xs: list):\n    \"\"\" xs are coefficients of a polynomial.\n    find_zero find x such that poly(x) = 0.\n    find_zero returns only only zero point, even if there are many.\n    Moreover, find_zero only takes list xs having even number of coefficients\n    and largest non zero coefficient as it guarantees\n    a solution.\n    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x\n    -0.5\n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    \"\"\"\n    if len(xs) % 2 != 0:\n        raise ValueError(\"The list of coefficients must have an even number of elements.\")\n    \n    max_coeff = max(xs)\n    if max_coeff == 0:\n        raise ValueError(\"The largest non-zero coefficient must be guaranteed to have a solution.\")\n    \n    # Find the value of x such that poly(x) = 0\n    x = -max_coeff / xs[-2]\n    return x", "result": "failed:  (type: AssertionError)", "passed": false}
{"task_id": "HumanEval/33", "completion": "def sort_third(l: list):\n    # Create a new list to store the sorted values\n    sorted_list = []\n    \n    # Iterate over the indices of the input list\n    for i in range(len(l)):\n        # Check if the index is divisible by three\n        if i % 3 == 0:\n            # Sort the value at the index and append it to the sorted list\n            sorted_list.append(sorted(l[i]))\n        else:\n            # Append the value at the index to the sorted list\n            sorted_list.append(l[i])\n    \n    # Flatten the sorted list and return it\n    return [item for sublist in sorted_list for item in sublist]", "result": "failed: 'int' object is not iterable (type: TypeError)", "passed": false}
{"task_id": "HumanEval/36", "completion": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            if '7' in str(i):\n                count += 1\n    return count", "result": "failed:  (type: AssertionError)", "passed": false}
{"task_id": "HumanEval/37", "completion": "def sort_even(lst):\n    even_indices = [lst[i] for i in range(len(lst)) if i % 2 == 0]\n    sorted_even = sorted(even_indices)\n    merged_lst = [sorted_even[i] if i % 2 == 0 else lst[i] for i in range(len(lst))]\n    return merged_lst", "result": "failed: list index out of range (type: IndexError)", "passed": false}
{"task_id": "HumanEval/38", "completion": "def encode_cyclic(string):\n    if not string:\n        return \"\"\n    \n    encoded_string = \"\"\n    rotation = 1\n    for i in range(len(string)):\n        encoded_char = chr((ord(string[i]) - ord('a') + rotation) % 26 + ord('a'))\n        encoded_string += encoded_char\n        rotation += 1\n\n    return encoded_string", "result": "failed:  (type: AssertionError)", "passed": false}
{"task_id": "HumanEval/39", "completion": "def is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\n\ndef prime_fib(n):\n    if not isinstance(n, int) or n < 1:\n        return None\n    \n    fib_nums = [0, 1]\n    while len(fib_nums) < n + 1:\n        fib_nums.append(fib_nums[-1] + fib_nums[-2])\n    \n    prime_fib_nums = [num for num in fib_nums if is_prime(num)]\n    return prime_fib_nums[n]\n", "result": "failed: list index out of range (type: IndexError)", "passed": false}
{"task_id": "HumanEval/41", "completion": "def car_race_collision(n: int):\n    \"\"\"\n    Imagine a road that's a perfectly straight infinitely long line.\n    n cars are driving left to right;  simultaneously, a different set of n cars\n    are driving right to left.   The two sets of cars start out being very far from\n    each other.  All cars move in the same speed.  Two cars are said to collide\n    when a car that's moving left to right hits a car that's moving right to left.\n    However, the cars are infinitely sturdy and strong; as a result, they continue moving\n    in their trajectory as if they did not collide.\n\n    This function outputs the number of such collisions.\n    \"\"\"\n\n    # Initialize variables\n    left_cars = [i for i in range(n)]\n    right_cars = [i for i in range(n)]\n    collisions = 0\n\n    # Check for collisions\n    for left_car in left_cars:\n        if left_car in right_cars:\n            collisions += 1\n    \n    return collisions\n", "result": "failed:  (type: AssertionError)", "passed": false}
{"task_id": "HumanEval/55", "completion": "def fib(n: int):\n    if n <= 0:\n        return 0\n    \n    a, b = 0, 1\n\n    for _ in range(n - 1):\n        a, b = b, a + b\n    \n    return a", "result": "failed:  (type: AssertionError)", "passed": false}
{"task_id": "HumanEval/56", "completion": "import re\n\ndef correct_bracketing(brackets: str):\n    opening_brackets = re.findall('<', brackets)\n    closing_brackets = re.findall('>', brackets)\n\n    return len(opening_brackets) == len(closing_brackets)", "result": "failed:  (type: AssertionError)", "passed": false}
