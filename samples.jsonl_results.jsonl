{"task_id": "HumanEval/0", "completion": "\nfrom typing import List\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Check if there are two elements in the given list that have a difference\n    less than the given threshold.\n    \n    Args:\n        numbers (List[float]): A list of numbers.\n        threshold (float): The maximum difference allowed between two elements.\n    \n    Returns:\n        bool: True if there are two close elements, False otherwise.\n    \"\"\"\n    try:\n        n = len(numbers)\n        for first_index in range(n):\n            for second_index in range(first_index+1, n):\n                if abs(numbers[first_index] - numbers[second_index]) < threshold:\n                    return True\n        return False\n    except TypeError:\n        return False\n\n", "result": "passed", "passed": true}
{"task_id": "HumanEval/1", "completion": "\nfrom typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    paren_string = paren_string.replace(\" \", \"\")\n    \n    result = []\n    stack = []\n    group_start_index = 0\n    \n    for i, char in enumerate(paren_string):\n        if char == \"(\":\n            stack.append(char)\n        elif char == \")\":\n            stack.pop()\n            \n            if not stack:\n                result.append(paren_string[group_start_index: i + 1])\n                group_start_index = i + 1\n    \n    return result\n", "result": "passed", "passed": true}
{"task_id": "HumanEval/2", "completion": "\ndef truncate_number(number: float) -> float:\n    \"\"\"\n    Truncates the decimal part of a given number and returns it.\n\n    Args:\n        number (float): The number to truncate.\n\n    Returns:\n        float: The truncated decimal part of the number.\n    \"\"\"\n    # Validate input\n    if not isinstance(number, float):\n        raise ValueError(\"Input must be a floating-point number\")\n\n    # Get the decimal part of the number\n    decimal_part = number - int(number)\n\n    # Return the decimal part\n    return decimal_part\n", "result": "passed", "passed": true}
{"task_id": "HumanEval/3", "completion": "from typing import List\n\ndef below_zero(transaction_list: List[int]) -> bool:\n    balance = 0\n    for transaction in transaction_list:\n        balance += transaction\n        if balance < 0:\n            return True\n    return False", "result": "passed", "passed": true}
{"task_id": "HumanEval/4", "completion": "from typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    if len(numbers) == 0:\n        return 0.0\n    \n    mean: float = sum(numbers) / len(numbers)\n    total_deviation: float = sum(abs(x - mean) for x in numbers)\n    mean_absolute_deviation: float = total_deviation / len(numbers)\n    \n    return mean_absolute_deviation", "result": "passed", "passed": true}
{"task_id": "HumanEval/5", "completion": "from typing import List\n\ndef validate_input(numbers: List[int], delimiter: int) -> None:\n    if not isinstance(numbers, list):\n        raise TypeError(\"'numbers' should be a list\")\n    if not isinstance(delimiter, int):\n        raise TypeError(\"'delimiter' should be an integer\")\n\ndef intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    validate_input(numbers, delimiter)\n    result = []\n    for i, num in enumerate(numbers):\n        result.append(num)\n        if i < len(numbers) - 1:\n            result.append(delimiter)\n    return result", "result": "passed", "passed": true}
{"task_id": "HumanEval/6", "completion": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    result = []\n    groups = paren_string.split()\n    for group in groups:\n        max_depth = 0 \n        current_depth = 0 \n        for char in group:\n            if char == \"(\":\n                current_depth += 1 \n                if current_depth > max_depth:\n                    max_depth = current_depth \n            elif char == \")\":\n                current_depth -= 1 \n        result.append(max_depth)\n    return result", "result": "passed", "passed": true}
{"task_id": "HumanEval/7", "completion": "\nfrom typing import List\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    filtered_strings = []\n    for string in strings:\n        if substring in string:\n            filtered_strings.append(string)\n    return filtered_strings\n", "result": "passed", "passed": true}
{"task_id": "HumanEval/8", "completion": "from typing import List, Tuple\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    sum_total = 0\n    product_total = 1\n\n    for num in numbers:\n        sum_total += num\n        product_total *= num\n\n    return sum_total, product_total", "result": "passed", "passed": true}
{"task_id": "HumanEval/9", "completion": "from typing import List\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    rolling_max_list = []\n    if numbers:\n        rolling_max_list.append(numbers[0])\n        for i in range(1, len(numbers)):\n            max_num = max(numbers[i], rolling_max_list[i-1])\n            rolling_max_list.append(max_num)\n    return rolling_max_list", "result": "passed", "passed": true}
{"task_id": "HumanEval/10", "completion": "\ndef is_palindrome(string: str) -> bool:\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    for i in range(len(string), 0, -1):\n        if string[:i] == string[:i][::-1]:\n            return string + string[:i-1][::-1]\n    return \"\"\n", "result": "failed: ", "passed": false}
{"task_id": "HumanEval/11", "completion": "from typing import List\n\ndef string_xor_operation(a: str, b: str) -> str:\n    if len(a) != len(b):\n        raise ValueError(\"Input strings must have the same length\")\n    \n    for char in a + b:\n        if char not in ['0', '1']:\n            raise ValueError(\"Input strings must only contain 0s and 1s\")\n    \n    result = ''\n    for i in range(len(a)):\n        if a[i] == b[i]:\n            result += '0'\n        else:\n            result += '1'\n    \n    return result", "result": "failed: ", "passed": false}
{"task_id": "HumanEval/12", "completion": "from typing import List, Optional\n\ndef longest(strings: List[str]) -> Optional[str]:\n    if not strings:\n        return None\n    \n    longest_string = strings[0]\n    for string in strings:\n        if len(string) > len(longest_string):\n            longest_string = string\n    \n    return longest_string", "result": "passed", "passed": true}
{"task_id": "HumanEval/13", "completion": "import math\n\ndef greatest_common_divisor(num1: int, num2: int) -> int:\n    if not isinstance(num1, int) or not isinstance(num2, int):\n        raise ValueError(\"Both inputs must be integers\")\n    \n    return math.gcd(num1, num2)", "result": "passed", "passed": true}
{"task_id": "HumanEval/14", "completion": "from typing import List\n\ndef all_prefixes(string: str) -> List[str]:\n    prefixes = []\n    for i in range(len(string)):\n        prefixes.append(string[:i+1])\n    return prefixes", "result": "passed", "passed": true}