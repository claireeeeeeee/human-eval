{"task_id": "HumanEval/0", "completion": "from typing import List\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for i, number_i in enumerate(numbers):\n        for j, number_j in enumerate(numbers):\n            if i != j:\n                if abs(number_i - number_j) < threshold:\n                    return True\n    \n    return False", "result": "passed", "passed": true}
{"task_id": "HumanEval/1", "completion": "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    paren_string = paren_string.replace(\" \", \"\")\n    groups = []\n    open_count = 0\n    close_count = 0\n    start_index = 0\n\n    for i, char in enumerate(paren_string):\n        if char == \"(\":\n            open_count += 1\n        elif char == \")\":\n            close_count += 1\n\n        if open_count == close_count:\n            group = paren_string[start_index:i + 1]\n            groups.append(group)\n            start_index = i + 1\n            open_count = 0\n            close_count = 0\n\n    if open_count != close_count:\n        raise ValueError(\"Unbalanced parentheses\")\n\n    return groups", "result": "passed", "passed": true}
{"task_id": "HumanEval/2", "completion": "def truncate_number(number: float) -> float:\n    if not isinstance(number, float) or number < 0.0:\n        raise ValueError(\"Invalid input! Please provide a positive floating-point number.\")\n    decimal_part = number % 1.0\n    return decimal_part", "result": "passed", "passed": true}
{"task_id": "HumanEval/3", "completion": "from typing import List\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\"\n    Determine if the account balance falls below zero at any point during a series of operations.\n\n    Args:\n        operations (List[int]): List of operations, where positive values represent deposits and negative values represent withdrawals.\n\n    Returns:\n        bool: True if the account balance falls below zero, False otherwise.\n    \"\"\"\n    balance = 0\n    for operation in operations:\n        if operation > 0:\n            balance += operation\n        else:\n            balance -= abs(operation)\n        \n        if balance < 0:\n            return True\n    \n    return False", "result": "passed", "passed": true}
{"task_id": "HumanEval/4", "completion": "from typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    absolute_differences = [abs(num - mean) for num in numbers]\n    return sum(absolute_differences) / len(numbers)", "result": "passed", "passed": true}
{"task_id": "HumanEval/5", "completion": "from typing import List\n\ndef intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    if not isinstance(numbers, list):\n        raise TypeError(\"The 'numbers' parameter must be a list\")\n    if not isinstance(delimiter, int):\n        raise TypeError(\"The 'delimiter' parameter must be an integer\")\n    \n    result = []\n    for i in range(len(numbers)):\n        result.append(numbers[i])\n        if i < len(numbers) - 1:\n            result.append(delimiter)\n    \n    return result", "result": "passed", "passed": true}
{"task_id": "HumanEval/6", "completion": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    groups = paren_string.split()\n\n    def calculate_nested_level(group: str) -> int:\n        open_count = group.count('(')\n        close_count = group.count(')')\n        return open_count - close_count\n\n    nested_levels = [calculate_nested_level(group) for group in groups]\n\n    return nested_levels", "result": "failed:  (type: AssertionError)", "passed": false}
{"task_id": "HumanEval/7", "completion": "from typing import List\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    if not strings or not substring:\n        return []\n\n    filtered_strings = []\n    for s in strings:\n        if substring in s:\n            filtered_strings.append(s)\n    return filtered_strings", "result": "passed", "passed": true}
{"task_id": "HumanEval/8", "completion": "from typing import List, Tuple\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    if not numbers:\n        return 0, 1\n    \n    total_sum = 0\n    product = 1\n    \n    for number in numbers:\n        total_sum += number\n        product *= number\n    \n    return total_sum, product", "result": "passed", "passed": true}
{"task_id": "HumanEval/9", "completion": "def rolling_max(numbers: List[int]) -> List[int]:\n    rolling_max_list = []\n\n    for i in range(len(numbers)):\n        max_num = max(numbers[i:])\n        rolling_max_list.append(max_num)\n\n    return rolling_max_list", "result": "failed:  (type: AssertionError)", "passed": false}
{"task_id": "HumanEval/10", "completion": "def is_palindrome(string: str) -> bool:\n    return string == string[::-1]\n\ndef make_palindrome(string: str) -> str:\n    if is_palindrome(string):\n        return string\n\n    for i in range(len(string)-1, -1, -1):\n        if is_palindrome(string[i:]):\n            return string + string[:i][::-1]", "result": "passed", "passed": true}
{"task_id": "HumanEval/11", "completion": "def string_xor(a: str, b: str) -> str:\n    if len(a) != len(b):\n        raise ValueError(\"Both input strings must have the same length\")\n\n    result = []\n    for char_a, char_b in zip(a, b):\n        char_xor = str(int(char_a) ^ int(char_b))\n        result.append(char_xor)\n    return ''.join(result)\n", "result": "passed", "passed": true}
{"task_id": "HumanEval/12", "completion": "from typing import List, Optional\n\ndef longest(strings: List[str]) -> Optional[str]:\n    if not strings:\n        return None\n    return max(strings, key=len)\n\n", "result": "passed", "passed": true}
{"task_id": "HumanEval/13", "completion": "def greatest_common_divisor(num1: int, num2: int) -> int:\n    # Step 1: Validate Inputs\n    if not isinstance(num1, int) or num1 <= 0 or not isinstance(num2, int) or num2 <= 0:\n        raise ValueError(\"Both parameters must be positive integers.\")\n\n    # Step 2: Base Case\n    if num1 == 0:\n        return abs(num2)\n    if num2 == 0:\n        return abs(num1)\n\n    # Step 3: Recursive Case\n    remainder = num1 % num2\n    return greatest_common_divisor(num2, remainder)", "result": "failed: Both parameters must be positive integers. (type: ValueError)", "passed": false}
{"task_id": "HumanEval/14", "completion": "from typing import List\n\ndef all_prefixes(string: str) -> List[str]:\n    prefixes = []\n    for i in range(1, len(string)+1):  \n        prefixes.append(string[:i])\n    return prefixes", "result": "passed", "passed": true}
{"task_id": "HumanEval/15", "completion": "def string_sequence(n: int) -> str:\n    if n <= 0:\n        return \"\"\n    \n    numbers = [str(i) for i in range(n + 1)]\n    sequence = ' '.join(numbers)\n    \n    return sequence\n", "result": "failed:  (type: AssertionError)", "passed": false}
{"task_id": "HumanEval/16", "completion": "def count_distinct_characters(string: str) -> int:\n    if not isinstance(string, str):\n        raise ValueError(\"Input must be a string\")\n\n    distinct_characters = set()\n    normalized_string = string.lower()\n\n    for char in normalized_string:\n        if char.isalpha():\n            distinct_characters.add(char)\n\n    return len(distinct_characters)\n", "result": "failed:  (type: AssertionError)", "passed": false}
{"task_id": "HumanEval/17", "completion": "from typing import List\n\ndef parse_music(music_string: str) -> List[int]:\n    note_durations = []\n    duration_mapping = {\n        'o': 4,\n        'o|': 2,\n        '.|': 1,\n    }\n    \n    for note in music_string.split():\n        note_durations.append(duration_mapping[note])\n    \n    return note_durations", "result": "passed", "passed": true}
{"task_id": "HumanEval/18", "completion": "from typing import List\n\ndef count_substring_occurrences(string: str, substring: str) -> int:\n    count = 0\n    substring_length = len(substring)\n    string_length = len(string)\n\n    for i in range(string_length - substring_length + 1):\n        if string[i:i+substring_length] == substring:\n            count += 1\n\n    return count", "result": "failed:  (type: AssertionError)", "passed": false}
{"task_id": "HumanEval/19", "completion": "def sort_numbers(numbers: str) -> str:\n    numerals = numbers.split()\n    numeral_mapping = {\n        \"zero\": 0,\n        \"one\": 1,\n        \"two\": 2,\n        \"three\": 3,\n        \"four\": 4,\n        \"five\": 5,\n        \"six\": 6,\n        \"seven\": 7,\n        \"eight\": 8,\n        \"nine\": 9\n    }\n    numerals = [numeral_mapping[num] for num in numerals]\n    numerals.sort()\n    num_to_word = {v: k for k, v in numeral_mapping.items()}\n    numerals = [num_to_word[num] for num in numerals]\n    return ' '.join(numerals)\n", "result": "passed", "passed": true}
{"task_id": "HumanEval/20", "completion": "from typing import List, Tuple\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    closest_1 = numbers[0]\n    closest_2 = numbers[1]\n    min_difference = abs(numbers[0] - numbers[1])\n    \n    for num in numbers[2:]:\n        difference = abs(num - closest_1)\n        if difference < min_difference:\n            closest_2 = closest_1\n            closest_1 = num\n            min_difference = difference\n        else:\n            difference = abs(num - closest_2)\n            if difference < min_difference:\n                closest_2 = num\n                min_difference = difference\n    \n    return tuple(sorted([closest_1, closest_2]))\n", "result": "failed:  (type: AssertionError)", "passed": false}
{"task_id": "HumanEval/21", "completion": "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\"\n    Rescales numbers in the input list to the range [0, 1].\n\n    Args:\n        numbers: A list of floats to be rescaled.\n\n    Returns:\n        A list of rescaled floats in the range [0, 1].\n\n    Raises:\n        ValueError: If the input list has less than two elements.\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"Input list must have at least two elements\")\n\n    min_num = min(numbers)\n    max_num = max(numbers)\n    rescaled_numbers = []\n    for num in numbers:\n        rescaled_num = (num - min_num) / (max_num - min_num)\n        rescaled_numbers.append(rescaled_num)\n    return rescaled_numbers\n", "result": "passed", "passed": true}
{"task_id": "HumanEval/22", "completion": "from typing import List, Any\n\ndef filter_integers(input_values: List[Any]) -> List[int]:\n    filtered_values = [value for value in input_values if isinstance(value, int)]\n    return filtered_values", "result": "passed", "passed": true}
{"task_id": "HumanEval/23", "completion": "from typing import List\n\ndef strlen(string: str) -> int:\n    if not isinstance(string, str):  # Input validation\n        raise TypeError(\"Input must be a string\")\n    return len(string)\n", "result": "passed", "passed": true}
{"task_id": "HumanEval/24", "completion": "def largest_divisor(n: int) -> int:\n    largest = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            largest = i\n    return largest", "result": "failed:  (type: AssertionError)", "passed": false}
{"task_id": "HumanEval/25", "completion": "from typing import List\n\ndef factorize(n: int) -> List[int]:\n    if n < 1:\n        return []\n    \n    factors = []\n    \n    while n % 2 == 0:\n        factors.append(2)\n        n = n // 2\n    \n    i = 3\n    while i * i <= n:\n        while n % i == 0:\n            factors.append(i)\n            n = n // i\n        i += 2\n    \n    if n > 2:\n        factors.append(n)\n    \n    return factors", "result": "passed", "passed": true}
{"task_id": "HumanEval/26", "completion": "from typing import List\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    Remove duplicate elements from a list while preserving the order.\n    \n    Args:\n        numbers (List[int]): List of integers\n        \n    Returns:\n        List[int]: List with duplicate elements removed\n    \n    Raises:\n        ValueError: If `numbers` is not a list of integers\n    \"\"\"\n    if not isinstance(numbers, list) or not all(isinstance(num, int) for num in numbers):\n        raise ValueError(\"Input must be a list of integers\")\n        \n    unique_numbers = []\n    seen = set()\n    for num in numbers:\n        if num not in seen:\n            unique_numbers.append(num)\n        seen.add(num)\n    return unique_numbers", "result": "failed:  (type: AssertionError)", "passed": false}
{"task_id": "HumanEval/27", "completion": "import string\n\ndef flip_case(input_string: str) -> str:\n    flipped_result = \"\"\n    for char in input_string:\n        if char.islower():\n            flipped_result += char.upper()\n        elif char.isupper():\n            flipped_result += char.lower()\n        else:\n            flipped_result += char\n    return flipped_result", "result": "passed", "passed": true}
{"task_id": "HumanEval/28", "completion": "from typing import List\n\ndef concatenate(strings: List[str]) -> str:\n    return ''.join(strings)", "result": "passed", "passed": true}
{"task_id": "HumanEval/29", "completion": "from typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    return [s for s in strings if s.startswith(prefix)]", "result": "passed", "passed": true}
{"task_id": "HumanEval/30", "completion": "def get_positive(l: list) -> list:\n    positive_numbers = []\n    \n    for num in l:\n        if num > 0:\n            positive_numbers.append(num)\n    \n    return positive_numbers", "result": "passed", "passed": true}
{"task_id": "HumanEval/31", "completion": "import math\n\ndef is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n\n    if n == 2:\n        return True\n\n    if n % 2 == 0:\n        return False\n\n    for i in range(3, math.isqrt(n) + 1, 2):\n        if n % i == 0:\n            return False\n\n    return True", "result": "passed", "passed": true}
{"task_id": "HumanEval/32", "completion": "import math\n\ndef poly(xs: list, x: float) -> float:\n    \"\"\"\n    Calculate the value of a polynomial at a given point.\n\n    Args:\n        xs (list): List of coefficients, from highest degree to lowest.\n        x (float): The point at which to evaluate the polynomial.\n\n    Returns:\n        float: The result of evaluating the polynomial at the given point.\n    \"\"\"\n    result = 0\n    for i, coeff in enumerate(xs):\n        result += coeff * x ** i\n    return result\n\n\ndef find_zero(xs: list) -> float:\n    \"\"\"\n    Find a zero point of a polynomial.\n\n    Args:\n        xs (list): List of coefficients, from highest degree to lowest.\n\n    Returns:\n        float: The zero point of the polynomial.\n    \"\"\"\n    if len(xs) % 2 != 0 or xs[-1] == 0:\n        raise ValueError(\"Invalid input: xs should have an even number of coefficients and the last coefficient should be non-zero.\")\n    \n    n = len(xs) - 1\n    a = xs[0]\n    b = xs[-1]\n    \n    if (a > 0 and b > 0) or (a < 0 and b < 0):\n        raise ValueError(\"Invalid input: The first and last coefficients should have opposite signs.\")\n    \n    if a < 0:\n        a = -a\n        b = -b\n    \n    return (b / a) ** (1 / n)\n", "result": "failed: Invalid input: The first and last coefficients should have opposite signs. (type: ValueError)", "passed": false}
{"task_id": "HumanEval/33", "completion": "def sort_third(input_list: list) -> list:\n    sorted_list = []\n\n    for i, element in enumerate(input_list):\n        if i % 3 == 0:\n            temp_list = get_divisible_by_three_elements(input_list, i)\n            temp_list.sort()\n            sorted_list.extend(temp_list)\n        else:\n            sorted_list.append(element)\n\n    return sorted_list\n\ndef get_divisible_by_three_elements(input_list: list, start_index: int) -> list:\n    divisible_by_three_elements = []\n    index = start_index\n    \n    while index < len(input_list) and index % 3 == 0:\n        divisible_by_three_elements.append(input_list[index])\n        index += 1\n\n    return divisible_by_three_elements", "result": "failed:  (type: AssertionError)", "passed": false}
{"task_id": "HumanEval/34", "completion": "import typing\n\ndef remove_duplicates_and_sort(input_list: list) -> list:\n    unique_elements_sorted = []\n    for element in input_list:\n        if element not in unique_elements_sorted:\n            unique_elements_sorted.append(element)\n    unique_elements_sorted.sort()\n    return unique_elements_sorted", "result": "failed:  (type: AssertionError)", "passed": false}
{"task_id": "HumanEval/35", "completion": "from typing import List\n\ndef max_element(l: List[int]) -> int:\n    if not l:\n        return 0\n    else:\n        return max(l)\n", "result": "passed", "passed": true}
{"task_id": "HumanEval/36", "completion": "def fizz_buzz(n: int) -> int:\n    if not isinstance(n, int) or n < 0:\n        raise ValueError(\"Input n must be a non-negative integer.\")\n    \n    count = 0\n    \n    # Iterate from 1 to n (including n)\n    for i in range(1, n+1):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    \n    return count\n", "result": "failed:  (type: AssertionError)", "passed": false}
{"task_id": "HumanEval/37", "completion": "from typing import List\n\ndef sort_even(l: List[int]) -> List[int]:\n    result = []\n    \n    for i in range(len(l)):\n        if i % 2 == 0:\n            sorted_even = sorted(l[::2])\n            l[i] = sorted_even[i // 2]\n        result.append(l[i])\n    \n    return result", "result": "failed:  (type: AssertionError)", "passed": false}
{"task_id": "HumanEval/38", "completion": "def encode_cyclic(s: str) -> str:\n    groups = [s[i:i+3] for i in range(0, len(s), 3)]\n    encoded_groups = []\n\n    for group in groups:\n        if len(group) < 3:\n            encoded_groups.append(group)\n        else:\n            encoded_groups.append(group[1:] + group[0])\n\n    return ''.join(encoded_groups)\n\n\ndef decode_cyclic(s: str) -> str:\n    groups = [s[i:i+3] for i in range(0, len(s), 3)]\n    decoded_groups = []\n\n    for group in groups:\n        if len(group) < 3:\n            decoded_groups.append(group)\n        else:\n            decoded_groups.append(group[-1] + group[:-1])\n\n    return ''.join(decoded_groups)", "result": "passed", "passed": true}
{"task_id": "HumanEval/39", "completion": "def prime_fib(n: int):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def is_fib(num):\n        a, b = 0, 1\n        while a <= num:\n            if a == num:\n                return True\n            a, b = b, a + b\n        return False\n\n    if n <= 0:\n        raise ValueError(\"Invalid input. n must be a positive integer.\")\n\n    count = 0\n    i = 2\n    while True:\n        if is_fib(i) and is_prime(i):\n            count += 1\n            if count == n:\n                return i\n        i += 1", "result": "timed out", "passed": false}
{"task_id": "HumanEval/40", "completion": "def triples_sum_to_zero(l: list):\n    if not isinstance(l, list):\n        return False\n    \n    if len(l) < 3:\n        return False\n\n    for i in range(len(l) - 2):\n        for j in range(i+1, len(l) - 1):\n            for k in range(j+1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n\n    return False", "result": "passed", "passed": true}
{"task_id": "HumanEval/41", "completion": "def car_race_collision(n: int) -> int:\n    collisions = 0\n    left_to_right = list(range(n))\n    right_to_left = list(range(n))\n    \n    left_to_right_pointer = 0\n    right_to_left_pointer = 0\n    \n    while left_to_right_pointer < n and right_to_left_pointer < n:\n        if left_to_right[left_to_right_pointer] < right_to_left[right_to_left_pointer]:\n            collisions += 1\n            left_to_right_pointer += 1\n        else:\n            right_to_left_pointer += 1\n            collisions += 1\n            if left_to_right[left_to_right_pointer-1] == right_to_left[right_to_left_pointer-1]:\n                return collisions\n            \n    return collisions", "result": "failed:  (type: AssertionError)", "passed": false}
{"task_id": "HumanEval/42", "completion": "def incr_list(l: list) -> list:\n    new_list = []\n    for element in l:\n        if isinstance(element, (int, float)):\n            new_list.append(element + 1)\n    return new_list", "result": "passed", "passed": true}
{"task_id": "HumanEval/43", "completion": "from typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    if not isinstance(l, list):\n        raise TypeError(\"Input must be a list\")\n\n    num_set = set()\n    for num in l:\n        if -num in num_set:\n            return True\n        num_set.add(num)\n\n    return False", "result": "passed", "passed": true}
{"task_id": "HumanEval/44", "completion": "def change_base(input_number, base):\n    if base >= 10:\n        raise ValueError(\"Invalid base: base must be less than 10\")\n    \n    result = \"\"\n    while input_number > 0:\n        remainder = input_number % base\n        result = str(remainder) + result\n        input_number = input_number // base\n\n    return result", "result": "passed", "passed": true}
{"task_id": "HumanEval/45", "completion": "from typing import Union\n\ndef triangle_area(a: float, h: float) -> Union[float, None]:\n    if not (isinstance(a, (int, float)) and isinstance(h, (int, float))):\n        return None\n    \n    if a <= 0 or h <= 0:\n        return None\n    \n    return 0.5 * a * h\n", "result": "passed", "passed": true}
{"task_id": "HumanEval/46", "completion": "def fib4(n: int) -> int:\n    fib0 = 0\n    fib1 = 1\n    fib2 = 1\n    fib3 = 2\n\n    if n == 0:\n        return fib0\n    elif n == 1:\n        return fib1\n    elif n == 2:\n        return fib2\n    elif n == 3:\n        return fib3\n\n    fib_n = 0\n\n    for i in range(4, n+1):\n        fib_n = fib0 + fib1 + fib2 + fib3\n        fib0 = fib1\n        fib1 = fib2\n        fib2 = fib3\n        fib3 = fib_n\n\n    return fib_n\n", "result": "failed:  (type: AssertionError)", "passed": false}
{"task_id": "HumanEval/47", "completion": "from typing import List\n\n\ndef median(l: List[int]) -> float:\n    \"\"\"\n    Calculate the median of a list of integers.\n    \n    Parameters:\n    l (List[int]): The input list of integers.\n    \n    Returns:\n    float: The median value of the input list.\n    \n    Raises:\n    ValueError: If the input list is empty or contains non-integer elements.\n    \"\"\"\n    # Input validation\n    if not isinstance(l, list):\n        raise ValueError(\"Input must be a list\")\n    if len(l) == 0:\n        raise ValueError(\"List cannot be empty\")\n    for num in l:\n        if not isinstance(num, int):\n            raise ValueError(\"List can only contain integer elements\")\n    \n    # Sort the list in ascending order\n    sorted_list = sorted(l)\n    length = len(sorted_list)\n    \n    # Check if the list has an odd number of elements\n    if length % 2 == 1:\n        # Return the middle element\n        return sorted_list[length // 2]\n    else:\n        # Return the average of the two middle elements\n        mid1 = sorted_list[length // 2 - 1]\n        mid2 = sorted_list[length // 2]\n        return (mid1 + mid2) / 2\n", "result": "passed", "passed": true}
{"task_id": "HumanEval/48", "completion": "def is_palindrome(text: str) -> bool:\n    \"\"\"\n    Checks if given string is a palindrome\n    \"\"\"\n    if not isinstance(text, str):\n        raise ValueError(\"Input must be a string\")\n\n    text = text.lower()\n    return text == text[::-1]\n\n", "result": "passed", "passed": true}
{"task_id": "HumanEval/49", "completion": "def modp(n: int, p: int):\n    result = pow(2, n) % p\n    return result\n", "result": "passed", "passed": true}
{"task_id": "HumanEval/50", "completion": "def encode_shift(s: str) -> str:\n    return \"\".join([chr((ord(c) - ord(\"a\") + 5) % 26 + ord(\"a\")) for c in s])\n\ndef decode_shift(s: str) -> str:\n    return \"\".join([chr((ord(c) - ord(\"a\") - 5) % 26 + ord(\"a\")) for c in s])", "result": "passed", "passed": true}
{"task_id": "HumanEval/51", "completion": "def remove_vowels(text: str) -> str:\n    if text is None or not isinstance(text, str):\n        raise ValueError(\"Input text must be a non-null string.\")\n    \n    vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n    result = []\n    \n    for char in text:\n        if char not in vowels:\n            result.append(char)\n    \n    return ''.join(result)", "result": "passed", "passed": true}
{"task_id": "HumanEval/52", "completion": "def below_threshold(l: list, t: int) -> bool:\n    \"\"\"\n    Check if any number in the list is greater than or equal to the threshold.\n\n    Args:\n        l (list): The list of numbers.\n        t (int): The threshold to compare the numbers against.\n\n    Returns:\n        bool: True if no number in the list is greater than or equal to the threshold, False otherwise.\n    \"\"\"\n    for num in l:\n        if num >= t:\n            return False\n    return True\n", "result": "passed", "passed": true}
{"task_id": "HumanEval/53", "completion": "def add(x: int, y: int):\n    \"\"\"\n    Add two numbers and return the result.\n\n    Args:\n        x (int): The first number.\n        y (int): The second number.\n\n    Returns:\n        int: The sum of x and y.\n    \"\"\"\n    return x + y", "result": "passed", "passed": true}
{"task_id": "HumanEval/54", "completion": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two strings have the same characters (regardless of order).\n    \"\"\"\n    set1 = set(s0)\n    set2 = set(s1)\n\n    return set1 == set2", "result": "passed", "passed": true}
{"task_id": "HumanEval/55", "completion": "def fib(n: int) -> int:\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        previous_fibonacci = 0\n        current_fibonacci = 1\n        \n        for i in range(2, n+1):\n            next_fibonacci = previous_fibonacci + current_fibonacci\n            previous_fibonacci = current_fibonacci\n            current_fibonacci = next_fibonacci\n        \n        return current_fibonacci", "result": "passed", "passed": true}
{"task_id": "HumanEval/56", "completion": "def correct_bracketing(brackets: str) -> bool:\n    stack = []\n\n    for bracket in brackets:\n        if bracket == '<':\n            stack.append(bracket)\n        elif bracket == '>':\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    \n    return len(stack) == 0\n", "result": "passed", "passed": true}
{"task_id": "HumanEval/57", "completion": "from typing import List\n\ndef is_sorted(l: List[int]) -> bool:\n    if len(l) <= 2:\n        return True\n\n    trend = 0\n    for i in range(1, len(l)):\n        diff = l[i] - l[i-1]\n        if diff != 0:\n            if trend == 0:\n                trend = diff\n            elif diff * trend < 0:\n                return False\n\n    return True\n\ndef monotonic(input_list: List[int]) -> bool:\n    if is_sorted(input_list):\n        return True\n    if is_sorted(input_list[::-1]):\n        return True\n    return False\n", "result": "passed", "passed": true}
{"task_id": "HumanEval/58", "completion": "def find_common_elements(list1: list, list2: list) -> list:\n    \"\"\"\n    Finds and returns the sorted common elements between two lists.\n    \n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n    \n    Returns:\n        list: A sorted list of common elements between list1 and list2.\n    \n    Raises:\n        ValueError: If either list1 or list2 is empty.\n    \"\"\"\n    if not isinstance(list1, list) or not isinstance(list2, list):\n        raise TypeError(\"Input parameters should be of type list\")\n    \n    if not list1 or not list2:\n        raise ValueError(\"Either list1 or list2 is empty\")\n\n    common_elements = set(list1) & set(list2)\n    sorted_elements = sorted(common_elements)\n    return sorted_elements", "result": "failed:  (type: AssertionError)", "passed": false}
{"task_id": "HumanEval/59", "completion": "import math\n\ndef largest_prime_factor(n: int) -> int:\n    if n <= 1:\n        return None\n\n    while n % 2 == 0:\n        n //= 2\n\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            n //= i\n\n    return n", "result": "failed:  (type: AssertionError)", "passed": false}
{"task_id": "HumanEval/60", "completion": "def sum_to_n(n):\n    if not isinstance(n, int) or n < 0:\n        raise ValueError(\"Input must be a non-negative integer\")\n    return (n * (n + 1)) // 2", "result": "passed", "passed": true}
{"task_id": "HumanEval/61", "completion": "def correct_bracketing(brackets: str) -> bool:\n    opening_brackets = {\n        \"(\": 0,\n        \"[\": 0,\n        \"{\": 0\n    }\n    closing_brackets = {\n        \")\": 0,\n        \"]\": 0,\n        \"}\": 0\n    }\n    \n    for bracket in brackets:\n        if bracket in opening_brackets:\n            opening_brackets[bracket] += 1\n        elif bracket in closing_brackets:\n            closing_brackets[bracket] += 1\n    \n    return (\n        opening_brackets[\"(\"] == closing_brackets[\")\"] and\n        opening_brackets[\"[\"] == closing_brackets[\"]\"] and\n        opening_brackets[\"{\"] == closing_brackets[\"}\"]\n    )", "result": "failed:  (type: AssertionError)", "passed": false}
{"task_id": "HumanEval/62", "completion": "def derivative(xs: list) -> list:\n    \"\"\"\n    Calculate the derivative of a polynomial.\n\n    Args:\n        xs (list): List of coefficients representing the polynomial.\n\n    Returns:\n        list: List of coefficients representing the derivative of the polynomial.\n    \"\"\"\n    if len(xs) < 2:\n        return []\n    \n    derivative_coeffs = []\n    for i, coeff in enumerate(xs[1:], start=1):\n        derivative_coeffs.append(coeff * i)\n    \n    return derivative_coeffs\n", "result": "passed", "passed": true}
{"task_id": "HumanEval/63", "completion": "def fibonacci_sequence(n: int) -> int:\n    if n < 0:\n        raise ValueError(\"Input must be a positive integer.\")\n    elif n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        sequence = [0, 1]\n        for i in range(2, n+1):\n            sequence.append(sequence[i-1] + sequence[i-2])\n        return sequence[n]\n\n\nThis code defines a function `fibonacci_sequence` which takes an integer `n` as input and returns the `n`th element of the Fibonacci sequence. It performs input validation and calculates the element iteratively using dynamic programming.", "result": "failed: invalid syntax (<string>, line 31) (type: SyntaxError)", "passed": false}
{"task_id": "HumanEval/64", "completion": "def vowels_count(s: str) -> int:\n    if not isinstance(s, str):\n        raise ValueError(\"Input must be a string.\")\n\n    vowel_count = 0\n    for char in s:\n        char_lower = char.lower()\n        if char_lower in ['a', 'e', 'i', 'o', 'u']:\n            vowel_count += 1\n        elif char_lower == 'y' and char == s[-1]:\n            vowel_count += 1\n\n    return vowel_count", "result": "passed", "passed": true}
{"task_id": "HumanEval/65", "completion": "def circular_shift(number: int, shift: int) -> str:\n    number_str = str(number)\n    actual_shift = shift % len(number_str)\n    if actual_shift == 0:\n        return number_str\n    if shift > len(number_str):\n        return number_str[::-1]\n    shifted_digits = number_str[-actual_shift:]\n    remaining_digits = number_str[:-actual_shift]\n    return shifted_digits + remaining_digits\n", "result": "failed:  (type: AssertionError)", "passed": false}
{"task_id": "HumanEval/66", "completion": "def digitSum(s: str) -> int:\n    if not isinstance(s, str):\n        raise ValueError(\"Input must be a string\")\n\n    digit_sum = 0\n    for char in s:\n        if char.isupper():\n            digit_sum += ord(char)\n    return digit_sum\n", "result": "passed", "passed": true}
{"task_id": "HumanEval/67", "completion": "def fruit_distribution(fruit_counts: str, total_fruits: int) -> int:\n    apple_count, orange_count = map(int, fruit_counts.split())\n    mango_count = total_fruits - apple_count - orange_count\n    return mango_count\n", "result": "failed: invalid literal for int() with base 10: 'apples' (type: ValueError)", "passed": false}
{"task_id": "HumanEval/68", "completion": "from typing import List\n\ndef get_smallest_even_node(nodes: List[int]) -> List[int]:\n    even_nodes = [node for node in nodes if node % 2 == 0]\n    if len(even_nodes) == 0:\n        return []\n    else:\n        smallest_even_node = even_nodes[0]\n        smallest_even_index = 0\n        for i in range(1, len(even_nodes)):\n            if even_nodes[i] < smallest_even_node:\n                smallest_even_node = even_nodes[i]\n                smallest_even_index = i\n        return [smallest_even_node, smallest_even_index]\n\n", "result": "failed: Error (type: AssertionError)", "passed": false}
{"task_id": "HumanEval/69", "completion": "def search(lst):\n    if not lst or any(i <= 0 for i in lst):\n        return -1\n    \n    frequencies = {}\n    max_value = -1\n    \n    for num in lst:\n        frequencies[num] = frequencies.get(num, 0) + 1\n    \n    for num, freq in frequencies.items():\n        if num > max_value and freq >= num:\n            max_value = num\n    \n    return max_value", "result": "passed", "passed": true}
{"task_id": "HumanEval/70", "completion": "from typing import List\n\ndef strange_sort_list(lst: List[int]) -> List[int]:\n    sorted_lst = sorted(lst)\n    result = []\n    for i in range(len(sorted_lst) // 2):\n        result.append(sorted_lst[i])\n        result.append(sorted_lst[-(i+1)])\n    if len(sorted_lst) % 2 != 0:\n        result.append(sorted_lst[len(sorted_lst) // 2])\n    return result\n", "result": "passed", "passed": true}
{"task_id": "HumanEval/71", "completion": "import math\n\ndef triangle_area(a: float, b: float, c: float) -> float:\n    if a + b > c and a + c > b and b + c > a:\n        s = (a + b + c) / 2\n        area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n        return round(area, 2)\n    else:\n        return -1", "result": "passed", "passed": true}
{"task_id": "HumanEval/72", "completion": "from typing import List\n\ndef is_balanced(arr: List[int]) -> bool:\n    return arr == arr[::-1]\n\ndef is_sum_valid(arr: List[int], weight: int) -> bool:\n    return sum(arr) <= weight\n\ndef will_it_fly(weights: List[int], weight_limit: int) -> bool:\n    if not is_balanced(weights):\n        return False\n    if not is_sum_valid(weights, weight_limit):\n        return False\n    return True\n", "result": "passed", "passed": true}
{"task_id": "HumanEval/73", "completion": "from typing import List\n\ndef calculate_minimum_changes(arr: List[int]) -> int:\n    if not arr:\n        return 0\n\n    changes = 0\n    left = 0\n    right = len(arr) - 1\n    \n    while left < right:\n        if arr[left] != arr[right]:\n            changes += 1\n        left += 1\n        right -= 1\n    \n    return changes\n\nNote: The final version of the code has been extracted from the developer's report. The code includes the `calculate_minimum_changes` function which takes a list of integers as input and returns the minimum number of changes required to make the array palindromic.", "result": "failed: invalid syntax (<string>, line 31) (type: SyntaxError)", "passed": false}
{"task_id": "HumanEval/74", "completion": "def total_match(lst1, lst2):\n    total_chars1 = sum(len(s) for s in lst1)\n    total_chars2 = sum(len(s) for s in lst2)\n\n    if total_chars1 < total_chars2:\n        return lst1\n    elif total_chars1 == total_chars2:\n        return lst1\n    else:\n        return lst2\n", "result": "passed", "passed": true}
{"task_id": "HumanEval/75", "completion": "def is_multiply_prime(a: int) -> bool:\n    if a < 2:\n        return False\n    \n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    \n    primes = []\n    for i in range(2, a):\n        if is_prime(i):\n            primes.append(i)\n            if len(primes) == 3:\n                break\n\n    if len(primes) < 3:\n        return False\n\n    product = 1\n    for prime in primes:\n        product *= prime\n        \n    return product == a\n", "result": "failed:  (type: AssertionError)", "passed": false}
{"task_id": "HumanEval/76", "completion": "import math\n\ndef is_simple_power(x: int, n: int) -> bool:\n    if x is None or n is None:\n        raise ValueError(\"x and n must not be None\")\n    \n    if x <= 0 or n <= 0:\n        raise ValueError(\"x and n must be positive integers\")\n    \n    if not isinstance(x, int) or not isinstance(n, int):\n        raise ValueError(\"x and n must be integers\")\n    \n    if x == 1:\n        return True\n    \n    if n == 1:\n        return False\n    \n    try:\n        p = math.log(x, n)\n    except ValueError:\n        raise ValueError(\"Invalid input: x is not a power of n\")\n    \n    return math.isclose(p, round(p))", "result": "passed", "passed": true}
{"task_id": "HumanEval/77", "completion": "import math\n\ndef iscube(a):\n    if not isinstance(a, int):\n        return False\n\n    cubic_root = math.pow(a, 1/3)\n\n    if not isinstance(a, int) or not cubic_root.is_integer():\n        return False\n\n    return True", "result": "failed: math domain error (type: ValueError)", "passed": false}
{"task_id": "HumanEval/78", "completion": "def hex_key(num):\n    prime_digits = ['2', '3', '5', '7', 'B', 'D']\n    count = 0\n    for digit in num:\n        if digit in prime_digits:\n            count += 1\n    return count", "result": "passed", "passed": true}
{"task_id": "HumanEval/79", "completion": "def decimal_to_binary(decimal: int) -> str:\n    try:\n        binary = bin(decimal)[2:]\n        return f\"db{binary}db\"\n    except TypeError:\n        return \"Invalid input. Please provide a valid decimal number.\"\n", "result": "passed", "passed": true}
{"task_id": "HumanEval/80", "completion": "def is_happy(s: str) -> bool:\n    # Check if the string length is less than 3 characters\n    if len(s) < 3:\n        return False\n    \n    # Iterate over the string, checking for repeated characters\n    for i in range(2, len(s)):\n        # If the current character is the same as the previous two characters,\n        # return False as it violates the \"happy\" pattern\n        if s[i] == s[i-1] or s[i] == s[i-2]:\n            return False\n    \n    return True", "result": "passed", "passed": true}
{"task_id": "HumanEval/81", "completion": "def numerical_letter_grade(grades):\n    grade_thresholds = {\n        4.0: 'A+',\n        3.7: 'A',\n        3.3: 'A-',\n        3.0: 'B+',\n        2.7: 'B',\n        2.3: 'B-',\n        2.0: 'C+',\n        1.7: 'C',\n        1.3: 'C-',\n        1.0: 'D+',\n        0.7: 'D',\n        0.0: 'D-',\n    }\n    \n    letter_grades = []\n    \n    for gpa in grades: \n        if gpa < 0 or gpa > 4.0:\n            raise ValueError(\"Invalid GPA: {0}. GPA must be between 0.0 and 4.0.\".format(gpa))\n\n        for threshold, grade in grade_thresholds.items():\n            if gpa >= threshold:\n                letter_grades.append(grade)\n                break\n        else:\n            letter_grades.append('E')\n            \n    return letter_grades", "result": "failed:  (type: AssertionError)", "passed": false}
{"task_id": "HumanEval/82", "completion": "import math\n\ndef prime_length(string: str) -> bool:\n    length = len(list(string))\n    \n    if length <= 1:\n        raise ValueError(\"Length must be greater than 1.\")\n    \n    sqrt_length = math.isqrt(length)\n    for i in range(2, sqrt_length + 1):\n        if length % i == 0:\n            return False\n    \n    return True", "result": "failed: Length must be greater than 1. (type: ValueError)", "passed": false}
{"task_id": "HumanEval/83", "completion": "def starts_one_ends(n: int) -> int:\n    if n < 1:\n        return 0\n    \n    min_value = 10 ** (n-1)\n    max_value = (10 ** n) - 1\n    \n    num_numbers = max_value - min_value + 1\n    num_non_start_end = 9 * 10 ** (n-2)\n    num_non_start = num_numbers - num_non_start_end\n    \n    count_start_with_one = num_numbers - num_non_start\n    \n    count_end_with_one = (9 * 10 ** (n-2)) + (9 * (10 ** (n-1))) - count_start_with_one\n    \n    return count_start_with_one + count_end_with_one", "result": "failed:  (type: AssertionError)", "passed": false}
{"task_id": "HumanEval/84", "completion": "def calculate_binary_sum(binary_str: str) -> int:\n    return sum(int(digit) for digit in binary_str)\n\n\ndef convert_to_binary_string(decimal_num: int) -> str:\n    return bin(decimal_num)[2:]\n\n\ndef sum_of_binary_digits(positive_integer: int) -> str:\n    binary_str = convert_to_binary_string(positive_integer)\n    binary_sum = calculate_binary_sum(binary_str)\n    binary_sum_str = convert_to_binary_string(binary_sum)\n    return binary_sum_str\n\nRemember to remove the comments and additional test cases as well.", "result": "failed: invalid syntax (<string>, line 30) (type: SyntaxError)", "passed": false}
{"task_id": "HumanEval/85", "completion": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    sum = 0\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            sum += lst[i]\n    return sum", "result": "passed", "passed": true}
{"task_id": "HumanEval/86", "completion": "def anti_shuffle(input_string):\n    \"\"\"\n    Sorts the words in the input string based on their ASCII values.\n\n    Args:\n        input_string (str): The input string containing words.\n\n    Returns:\n        str: The input string with sorted words.\n    \"\"\"\n\n    def sort_word(word):\n        \"\"\"\n        Sorts the characters in a word based on their ASCII values.\n\n        Args:\n            word (str): The word to be sorted.\n\n        Returns:\n            str: The sorted word.\n        \"\"\"\n        ordered_chars = sorted(list(word))\n        return \"\".join(ordered_chars)\n\n    words = input_string.split()\n    ordered_words = [sort_word(word) for word in words]\n    return \" \".join(ordered_words)", "result": "passed", "passed": true}
{"task_id": "HumanEval/87", "completion": "from typing import List, Tuple\nimport operator\n\ndef get_coordinates(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    coordinates = []\n    for i, row in enumerate(lst):\n        for j, num in enumerate(row):\n            if num == x:\n                coordinates.append((i, j))\n    \n    coordinates.sort()\n    coordinates.sort(key=operator.itemgetter(1), reverse=True)\n    \n    return coordinates\n", "result": "failed:  (type: AssertionError)", "passed": false}
{"task_id": "HumanEval/88", "completion": "def sort_array(array):\n    \"\"\"\n    Given an array of non-negative integers, return a copy of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n    \"\"\"\n    if array and (array[0] + array[-1]) % 2 == 0:\n        return sorted(array, reverse=True)\n    else:\n        return sorted(array)\n", "result": "passed", "passed": true}
{"task_id": "HumanEval/89", "completion": "def encrypt(s: str) -> str:\n    shift = 4\n    encrypted = []\n    for char in s:\n        if char.islower():\n            encrypted_char = chr((ord(char) - ord('a') + shift) % 26 + ord('a'))\n            encrypted.append(encrypted_char)\n        else:\n            encrypted.append(char)\n    return ''.join(encrypted)", "result": "passed", "passed": true}
{"task_id": "HumanEval/90", "completion": "from typing import List\n\ndef next_smallest(input_list: List[int]) -> int:\n    sorted_lst = sorted(input_list)\n    \n    if len(sorted_lst) < 2:\n        return None\n    \n    return sorted_lst[1]\n", "result": "failed:  (type: AssertionError)", "passed": false}
{"task_id": "HumanEval/91", "completion": "import re\n\ndef is_bored(input_string: str) -> int:\n    sentences = re.split(r'[\\.\\?!]+', input_string)\n    count = 0\n    for sentence in sentences:\n        if sentence.strip().startswith(\"I\"):\n            count += 1\n    return count", "result": "failed: Test 2 (type: AssertionError)", "passed": false}
{"task_id": "HumanEval/92", "completion": "def any_int(x: int, y: int, z: int) -> bool:\n    if not all(isinstance(i, int) for i in (x, y, z)):\n        return False\n    return x + y == z or y + z == x or x + z == y", "result": "passed", "passed": true}
{"task_id": "HumanEval/93", "completion": "def encode(message: str) -> str:\n    if not message:\n        return message\n    \n    encoded_message = \"\"\n    for character in message.upper():\n        if character.isalpha():\n            if character in ['A', 'E', 'I', 'O', 'U']:\n                encoded_message += chr(ord(character) + 2)\n            else:\n                encoded_message += character.swapcase()\n        else:\n            encoded_message += character\n    \n    return encoded_message", "result": "failed: This prints if this assert fails 1 (good for debugging!) (type: AssertionError)", "passed": false}
{"task_id": "HumanEval/94", "completion": "def largest_prime_sum_digits(lst):\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    largest_prime = 0\n    prime_sum_digits = 0\n\n    for num in lst:\n        if is_prime(num) and num > largest_prime:\n            largest_prime = num\n\n    for digit in str(largest_prime):\n        prime_sum_digits += int(digit)\n\n    return prime_sum_digits\n", "result": "failed: This prints if this assert fails 1 (good for debugging!) (type: AssertionError)", "passed": false}
{"task_id": "HumanEval/95", "completion": "from typing import Dict\n\ndef check_dict_case(dictionary: Dict[str, str]) -> bool:\n    if not isinstance(dictionary, dict):\n        return False\n\n    lower_case_keys = []\n    upper_case_keys = []\n\n    for key in dictionary.keys():\n        if not isinstance(key, str):\n            return False\n\n        if key.islower():\n            lower_case_keys.append(key)\n        elif key.isupper():\n            upper_case_keys.append(key)\n        else:\n            return False\n\n    return len(lower_case_keys) == 0 and len(upper_case_keys) == 0\n", "result": "failed: First test error: False (type: AssertionError)", "passed": false}
{"task_id": "HumanEval/96", "completion": "def count_up_to(n):\n    primes = []\n    if n < 2:\n        return primes\n    for num in range(2, n):\n        if all(num % i != 0 for i in range(2, int(num ** 0.5) + 1)):\n            primes.append(num)\n    return primes", "result": "passed", "passed": true}
{"task_id": "HumanEval/97", "completion": "def multiply(a: int, b: int) -> int:\n    unit_digit_a = a % 10\n    unit_digit_b = b % 10\n    result = unit_digit_a * unit_digit_b\n    return result", "result": "passed", "passed": true}
{"task_id": "HumanEval/98", "completion": "def count_upper(input_string: str) -> int:\n    counter = 0\n    for i, char in enumerate(input_string):\n        if char in ['A', 'E', 'I', 'O', 'U'] and i % 2 == 0:\n            counter += 1\n    return counter", "result": "passed", "passed": true}
{"task_id": "HumanEval/99", "completion": "import math\n\ndef closest_integer(value: str) -> int:\n    try:\n        num = float(value)\n    except ValueError:\n        raise ValueError(\"Invalid input value: must be a valid numeric string\")\n    \n    rounded_num = round(num)\n    \n    if num % 1 == 0.5:\n        return math.ceil(rounded_num)\n    \n    return rounded_num", "result": "failed: Test 2 (type: AssertionError)", "passed": false}
{"task_id": "HumanEval/100", "completion": "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    stone_pile = []\n    stone_pile.append(n)\n    for level in range(2, n + 1):\n        if level % 2 == 1:\n            stones = stone_pile[level - 2] + 2\n        else:\n            stones = stone_pile[level - 2] + 1\n        stone_pile.append(stones)\n    return stone_pile", "result": "failed: Test 3 (type: AssertionError)", "passed": false}
{"task_id": "HumanEval/101", "completion": "import re\nfrom typing import List\n\ndef extract_words(s: str) -> List[str]:\n    words = re.findall(r'\\w+', s)\n    return words", "result": "failed:  (type: AssertionError)", "passed": false}
{"task_id": "HumanEval/102", "completion": "def choose_num(x, y):\n    if x > y:\n        return -1\n    for num in range(y, x-1, -1):\n        if num % 2 == 0:\n            return num\n    return -1", "result": "passed", "passed": true}
{"task_id": "HumanEval/103", "completion": "def rounded_avg(n: int, m: int) -> str:\n    \"\"\"\n    Calculates the rounded average of integers from n to m,\n    and returns its binary representation as a string.\n    \n    Args:\n        n (int): The starting integer.\n        m (int): The ending integer.\n\n    Returns:\n        str: The binary representation of the rounded average.\n\n    Raises:\n        ValueError: If n or m is not a positive integer.\n    \"\"\"\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    if not isinstance(m, int) or m <= 0:\n        raise ValueError(\"m must be a positive integer\")\n    \n    if n > m:\n        return \"-1\"\n    \n    total = 0\n    count = m - n + 1\n    \n    for i in range(n, m+1):\n        total += i\n        \n    average = round(total / count)\n    binary = bin(average)[2:]\n    return binary", "result": "failed:  (type: AssertionError)", "passed": false}
{"task_id": "HumanEval/104", "completion": "from typing import List\n\ndef get_numbers_without_even_digits(number_list: List[int]) -> List[int]:\n    unique_numbers = []\n    \n    for num in number_list:\n        has_even_digit = False\n        for digit in str(num):\n            if int(digit) % 2 == 0:\n                has_even_digit = True\n                break\n        \n        if not has_even_digit:\n            unique_numbers.append(num)\n    \n    return sorted(unique_numbers)", "result": "failed:  (type: AssertionError)", "passed": false}
{"task_id": "HumanEval/105", "completion": "def by_length(arr):\n    filtered_arr = [num for num in arr if isinstance(num, int) and 1 <= num <= 9]\n    sorted_arr = sorted(filtered_arr)\n    reversed_arr = sorted_arr[::-1]\n    digit_name_map = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\"\n    }\n    result = [digit_name_map[num] for num in reversed_arr]\n    return result", "result": "passed", "passed": true}
{"task_id": "HumanEval/106", "completion": "from typing import List\nimport math\n\ndef f(n: int) -> List[int]:\n    result = []\n    for i in range(1, n+1):\n        if i % 2 == 0:\n            result.append(calculate_factorial(i))\n        else:\n            result.append(calculate_sum_of_numbers(i))\n    return result\n\ndef calculate_factorial(n: int) -> int:\n    return math.factorial(n)\n\ndef calculate_sum_of_numbers(n: int) -> int:\n    return sum(range(1, n+1))\n", "result": "passed", "passed": true}
{"task_id": "HumanEval/107", "completion": "from typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    if n < 1 or n > 1000:\n        return (0, 0)\n    \n    even_count = 0\n    odd_count = 0\n    \n    for num in range(1, n+1):\n        if str(num) == str(num)[::-1]:\n            if num % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n    \n    return (even_count, odd_count)\n", "result": "passed", "passed": true}
{"task_id": "HumanEval/108", "completion": "from typing import List\n\ndef sum_of_digits(num: int) -> int:\n    return sum(int(d) for d in str(abs(num)))\n\ndef count_nums(numbers: List[int]) -> int:\n    count = 0\n    for num in numbers:\n        digit_sum = sum_of_digits(num)\n        if digit_sum > 0:\n            count += 1\n    return count\n", "result": "failed:  (type: AssertionError)", "passed": false}
{"task_id": "HumanEval/109", "completion": "from typing import List\n\ndef move_one_ball(number_list: List[int]) -> bool:\n    if not number_list or sorted(number_list) == number_list:\n        return True\n    \n    previous_number = number_list[0]\n    swap_count = 0\n    \n    for number in number_list[1:]:\n        if number < previous_number:\n            swap_count += 1\n            if swap_count > 1:\n                return False\n        \n        previous_number = number\n    \n    return True", "result": "passed", "passed": true}
{"task_id": "HumanEval/110", "completion": "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd_count = 0\n\n    for num in lst1:\n        if num % 2 != 0:\n            odd_count += 1\n\n    for num in lst2:\n        if num % 2 != 0:\n            odd_count -= 1\n\n    if odd_count >= 0:\n        return \"YES\"\n    else:\n        return \"NO\"\n", "result": "failed:  (type: AssertionError)", "passed": false}
{"task_id": "HumanEval/111", "completion": "from collections import defaultdict\n\ndef histogram(test: str) -> dict:\n    frequencies = defaultdict(int)\n    \n    for letter in test:\n        if letter.isalpha():\n            frequencies[letter.lower()] += 1\n    \n    if not frequencies:\n        return {}\n    \n    max_count = max(frequencies.values())\n    max_letters = {letter: count for letter, count in frequencies.items() if count == max_count}\n    \n    return max_letters\n", "result": "passed", "passed": true}
{"task_id": "HumanEval/112", "completion": "from typing import Tuple\n\ndef reverse_delete(s: str, c: str) -> Tuple[str, bool]:\n    result = \"\"\n    \n    for char in s:\n        if char not in c:\n            result += char\n    \n    is_palindrome = result == result[::-1]\n    \n    return result, is_palindrome", "result": "passed", "passed": true}
{"task_id": "HumanEval/113", "completion": "from typing import List\n\ndef odd_count(input_strings: List[str]) -> List[str]:\n    result = []\n    for string in input_strings:\n        count = 0\n        for char in string:\n            if char.isdigit() and int(char) % 2 != 0:\n                count += 1\n        formatted_string = f\"The number of odd elements {count} in the string '{string}' of the input.\"\n        result.append(formatted_string)\n    return result", "result": "failed: Test 1 (type: AssertionError)", "passed": false}
{"task_id": "HumanEval/114", "completion": "def minSubArraySum(nums: List[int]) -> int:\n    min_sum = float('inf')\n    \n    for start in range(len(nums)):\n        running_sum = 0\n        \n        for end in range(start, len(nums)):\n            running_sum += nums[end]\n            min_sum = min(min_sum, running_sum)\n    \n    return min_sum", "result": "failed: name 'List' is not defined (type: NameError)", "passed": false}
{"task_id": "HumanEval/115", "completion": "def max_fill(grid, bucket_capacity):\n    num_lowerings = 0\n    for row in grid:\n        for well in row:\n            if well == 1:\n                num_lowerings += math.ceil(bucket_capacity / well)\n    return num_lowerings", "result": "failed: name 'math' is not defined (type: NameError)", "passed": false}
{"task_id": "HumanEval/116", "completion": "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    binary_arr = [bin(num)[2:] for num in arr]\n    tuples = [(num, binary, binary.count('1')) for num, binary in zip(arr, binary_arr)]\n    sorted_tuples = sorted(tuples, key=lambda x: (x[2], x[0]))\n    sorted_arr = [t[0] for t in sorted_tuples]\n    return sorted_arr", "result": "passed", "passed": true}
{"task_id": "HumanEval/117", "completion": "def select_words(input_string: str, consonant_count: int) -> List[str]:\n    words = input_string.split()\n    result = []\n\n    for word in words:\n        count = 0\n        for char in word:\n            if char.isalpha() and char.lower() not in 'aeiou':\n                count += 1\n        if count == consonant_count:\n            result.append(word)\n    \n    return result\n", "result": "failed: name 'List' is not defined (type: NameError)", "passed": false}
{"task_id": "HumanEval/118", "completion": "import string\n\ndef get_closest_vowel(input_word: str) -> str:\n    consonants = \"\"\n    for letter in reversed(input_word):\n        if letter.lower() not in string.ascii_lowercase or letter in \"aeiouAEIOU\":\n            break\n        consonants += letter\n    consonants = consonants[::-1]\n    \n    for letter in consonants:\n        if letter.lower() in \"aeiou\":\n            return letter\n    \n    return \"\"\n", "result": "failed:  (type: AssertionError)", "passed": false}
{"task_id": "HumanEval/119", "completion": "import re\nfrom typing import List\n\ndef match_parens(lst: List[str]) -> str:\n    string = ''.join(lst)\n    string = re.sub('[^()]', '', string)\n    stack = []\n    \n    for char in string:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if stack:\n                stack.pop()\n            else:\n                return 'No'\n    \n    if stack:\n        return 'No'\n    else:\n        return 'Yes'", "result": "failed:  (type: AssertionError)", "passed": false}
{"task_id": "HumanEval/120", "completion": "from typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    max_numbers = sorted(arr, reverse=True)\n    return max_numbers[:k]", "result": "failed:  (type: AssertionError)", "passed": false}
{"task_id": "HumanEval/121", "completion": "from typing import List\n\ndef solution(lst: List[int]) -> int:\n    return sum(lst[1::2])\n", "result": "failed:  (type: AssertionError)", "passed": false}
{"task_id": "HumanEval/122", "completion": "def add_elements(elements, limit):\n    if len(elements) < limit:\n        return 0\n\n    sum_elements = 0\n    for i in range(limit):\n        if len(str(elements[i])) <= 2:\n            sum_elements += elements[i]\n    return sum_elements", "result": "passed", "passed": true}
{"task_id": "HumanEval/123", "completion": "def get_odd_collatz(n):\n    odd_numbers = []\n    while n != 1:\n        if n % 2 == 1:  \n            odd_numbers.append(n)\n        if n % 2 == 0:  \n            n = n // 2\n        else:\n            n = n * 3 + 1\n    odd_numbers.append(1)  \n    return sorted(odd_numbers)", "result": "passed", "passed": true}
{"task_id": "HumanEval/124", "completion": "def valid_date(date: str) -> bool:\n    if not isinstance(date, str) or not date:\n        return False\n    \n    try:\n        month, day, year = date.split(\"-\")\n    except ValueError:\n        return False\n    \n    try:\n        month = int(month)\n        if month < 1 or month > 12:\n            return False\n    except ValueError:\n        return False\n    \n    try:\n        day = int(day)\n        if month == 2:\n            if day < 1 or day > 29:\n                return False\n        elif month in [4, 6, 9, 11]:\n            if day < 1 or day > 30:\n                return False\n        else:\n            if day < 1 or day > 31:\n                return False\n    except ValueError:\n        return False\n    \n    try:\n        year = int(year)\n        if year < 1:\n            return False\n    except ValueError:\n        return False\n    \n    return True", "result": "passed", "passed": true}
{"task_id": "HumanEval/125", "completion": "def split_words(txt: str) -> Union[List[str], int]:\n    if \" \" in txt:\n        return txt.split(\" \")\n    elif \",\" in txt:\n        return txt.split(\",\")\n    else:\n        return sum(1 for char in txt if char.islower() and ord(char) % 2 == 1)\n", "result": "failed: name 'Union' is not defined (type: NameError)", "passed": false}
{"task_id": "HumanEval/126", "completion": "from typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    if len(lst) <= 1:\n        return True\n\n    for i in range(1, len(lst)):\n        if lst[i] < lst[i-1]:\n            return False\n\n    return True\n", "result": "failed: This prints if this assert fails 5 (good for debugging!) (type: AssertionError)", "passed": false}
{"task_id": "HumanEval/127", "completion": "def intersection(interval1, interval2):\n    start1, end1 = interval1\n    start2, end2 = interval2\n    start = max(start1, start2)\n    end = min(end1, end2)\n    length = end - start + 1\n    \n    if start > end:\n        raise ValueError(\"Invalid interval: start value is greater than end value\")\n    \n    if length < 2:\n        return \"NO\"\n    \n    for i in range(2, isqrt(length) + 1):\n        if length % i == 0:\n            return \"NO\"\n    \n    return \"YES\"", "result": "failed: name 'isqrt' is not defined (type: NameError)", "passed": false}
{"task_id": "HumanEval/128", "completion": "from typing import List\n\ndef prod_signs(arr: List[float]) -> float:\n    if not arr:\n        raise ValueError(\"Input list cannot be empty\")\n\n    total_magnitude = 0\n    total_sign = 1\n\n    for num in arr:\n        if num == 0:\n            continue\n        magnitude = abs(num)\n        sign = num / magnitude\n        total_magnitude += magnitude\n        total_sign *= sign\n\n    return total_magnitude * total_sign\n", "result": "failed:  (type: AssertionError)", "passed": false}
{"task_id": "HumanEval/129", "completion": "from typing import List\n\ndef min_path(grid: List[List[int]], k: int) -> List[int]:\n    def dfs(row_index: int, column_index: int, path: List[int], visited: List[List[bool]]) -> List[int]:\n        if len(path) == k:\n            return path\n        neighbors = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        for row_shift, column_shift in neighbors:\n            neighbor_row, neighbor_column = row_index + row_shift, column_index + column_shift\n            if 0 <= neighbor_row < len(grid) and 0 <= neighbor_column < len(grid[0]) and not visited[neighbor_row][neighbor_column]:\n                visited[neighbor_row][neighbor_column] = True\n                path.append(grid[neighbor_row][neighbor_column])\n                res = dfs(neighbor_row, neighbor_column, path, visited)\n                if res:\n                    return res\n                path.pop()\n                visited[neighbor_row][neighbor_column] = False\n        return None\n        \n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            visited = [[False] * len(grid[0]) for _ in range(len(grid))]\n            path = [grid[i][j]]\n            visited[i][j] = True\n            res = dfs(i, j, path, visited)\n            if res:\n                return res\n    \n    return []\n", "result": "failed:  (type: AssertionError)", "passed": false}
{"task_id": "HumanEval/130", "completion": "from typing import List\n\ndef generate_tribonacci_sequence(n: int) -> List[int]:\n    if n == 0:\n        return [1]\n    elif n == 1:\n        return [1, 3]\n  \n    result = [1, 3]\n  \n    if n % 2 == 0:\n        for i in range(2, n + 1, 2):\n            result.append((result[i-1] + result[i-2]) // 2)\n    else:\n        for i in range(2, n + 1):\n            result.append(result[i-1] + result[i-2])\n  \n    return result", "result": "failed:  (type: AssertionError)", "passed": false}
{"task_id": "HumanEval/131", "completion": "def product_of_odd_digits(number: int) -> int:\n    product_of_odd_digits = 1\n    number_str = str(number)\n    \n    for digit in number_str:\n        if int(digit) % 2 != 0:\n            product_of_odd_digits *= int(digit)\n    \n    return product_of_odd_digits", "result": "failed:  (type: AssertionError)", "passed": false}
{"task_id": "HumanEval/132", "completion": "def is_nested(bracket_sequence: str) -> bool:\n    stack = []\n    for char in bracket_sequence:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if not stack:\n                return False\n            stack.pop()\n    return not stack\n", "result": "failed:  (type: AssertionError)", "passed": false}
{"task_id": "HumanEval/133", "completion": "from typing import List\n\ndef sum_squares(lst: List[float]) -> int:\n    total = 0\n    for num in lst:\n        rounded_num = round(num)\n        squared_num = rounded_num ** 2\n        total += squared_num\n    return total\n", "result": "failed: This prints if this assert fails 1 (good for debugging!) (type: AssertionError)", "passed": false}
{"task_id": "HumanEval/134", "completion": "def is_last_char_alphabetic_and_not_in_word(txt: str) -> bool:\n    if not txt.strip():\n        return False\n\n    last_char = txt[-1]\n    if not last_char.isalpha() or last_char == ' ' or txt[-2] != ' ':\n        return False\n\n    return True\n", "result": "failed:  (type: AssertionError)", "passed": false}
{"task_id": "HumanEval/135", "completion": "def can_arrange(arr):\n    sorted_array = sorted(arr)\n    \n    for i in range(1, len(sorted_array)):\n        if sorted_array[i] < sorted_array[i-1]:\n            return i-1\n    \n    return -1\n", "result": "failed:  (type: AssertionError)", "passed": false}
{"task_id": "HumanEval/136", "completion": "def largest_smallest_integers(lst):\n    largest_neg = None\n    smallest_pos = None\n    \n    for num in lst:\n        if num < 0 and (largest_neg is None or num > largest_neg):\n            largest_neg = num\n        elif num > 0 and (smallest_pos is None or num < smallest_pos):\n            smallest_pos = num\n    \n    return (largest_neg, smallest_pos)", "result": "passed", "passed": true}
{"task_id": "HumanEval/137", "completion": "def compare_one(value_a, value_b):\n    type_a = type(value_a)\n    type_b = type(value_b)\n\n    if type_a == type_b:\n        if type_a in (int, float):\n            return max(value_a, value_b)\n        elif type_a == str and '.' in value_a and '.' in value_b:\n            value_a = value_a.replace(',', '.')\n            value_b = value_b.replace(',', '.')\n            return max(float(value_a), float(value_b))\n        elif type_a == str and value_a.isdigit() and value_b.isdigit():\n            return max(value_a, value_b)\n\n    if (type_a in (int, float) and type_b == str and value_b.isdigit()) or \\\n            (type_b in (int, float) and type_a == str and value_a.isdigit()):\n        if type_b == str:\n            value_b = value_b.replace(',', '.')\n        if type_a == str:\n            value_a = value_a.replace(',', '.')\n        return max(float(value_a), float(value_b))\n\n    return None", "result": "failed:  (type: AssertionError)", "passed": false}
{"task_id": "HumanEval/138", "completion": "def is_equal_to_sum_even(n: int) -> bool:\n    if not isinstance(n, int) or n <= 0:\n        return False\n\n    for i in range(2, n//4+2, 2):\n        for j in range(2, n//4+2, 2):\n            for k in range(2, n//4+2, 2):\n                for l in range(2, n//4+2, 2):\n                    if i + j + k + l == n:\n                        return True\n                    elif i + j + k + l > n:\n                        break\n\n    return False", "result": "failed:  (type: AssertionError)", "passed": false}
{"task_id": "HumanEval/139", "completion": "import math\n\ndef special_factorial(n: int) -> int:\n    result = 1\n    for i in range(n, 0, -1):\n        result *= math.factorial(i) * math.factorial(i-1)\n    return result", "result": "failed: Test 4 (type: AssertionError)", "passed": false}
{"task_id": "HumanEval/140", "completion": "def fix_spaces(text):\n    modified_text = \"\"\n    consecutive_spaces = 0\n\n    for i in range(len(text)):\n        if text[i] == \" \":\n            consecutive_spaces += 1\n            if consecutive_spaces > 1:\n                modified_text += \"-\"\n            else:\n                modified_text += \"_\"\n        else:\n            modified_text += text[i]\n            consecutive_spaces = 0\n\n    return modified_text\n", "result": "failed: This prints if this assert fails 3 (good for debugging!) (type: AssertionError)", "passed": false}
{"task_id": "HumanEval/141", "completion": "def file_name_check(file_name: str) -> str:\n    if not file_name:\n        return 'No'\n    \n    parts = file_name.split('.')\n\n    if len(parts) != 2:\n        return 'No'\n    \n    digit_count = sum(1 for char in file_name if char.isdigit())\n    if digit_count > 3:\n        return 'No'\n\n    first_part = parts[0]\n    if not first_part or not first_part[0].isalpha():\n        return 'No'\n    \n    second_part = parts[1]\n    if second_part not in ['txt', 'exe', 'dll']:\n        return 'No'\n\n    return 'Yes'\n\n\nNote: I have removed the specific error messages and returned 'No' for invalid file names.", "result": "failed: invalid syntax (<string>, line 40) (type: SyntaxError)", "passed": false}
{"task_id": "HumanEval/142", "completion": "from typing import List\n\ndef sum_squares(lst: List[int]) -> int:\n    \"\"\"\n    Calculate the sum of squares and cubes of elements at specific indices in the given list.\n\n    Arguments:\n    lst -- The input list of integers.\n\n    Returns:\n    The sum of squares and cubes of elements at specific indices.\n\n    Raises:\n    TypeError -- If the input is not a list or not a list of integers.\n    \"\"\"\n\n    if not isinstance(lst, list):\n        raise TypeError(\"Input is not a list.\")\n\n    sum_total: int = 0  # Initialize a variable to keep track of the sum\n\n    for index, value in enumerate(lst):  # Iterate over the elements of the input list\n        if index % 3 == 0:  # Check if the index is a multiple of 3\n            sum_total += value ** 2  # Square the element and add it to the sum\n        elif index % 4 == 0:  # Check if the index is a multiple of 4 but not a multiple of 3\n            sum_total += value ** 3  # Cube the element and add it to the sum\n\n    return sum_total  # Return the final sum\n", "result": "failed:  (type: AssertionError)", "passed": false}
{"task_id": "HumanEval/143", "completion": "import math\n\ndef words_in_sentence(sentence: str) -> str:\n    sentence_words = sentence.split()\n    filtered_words = []\n    \n    for word in sentence_words:\n        if is_prime(len(word)):\n            filtered_words.append(word)\n    \n    return \" \".join(filtered_words)\n\ndef is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True", "result": "passed", "passed": true}
{"task_id": "HumanEval/144", "completion": "def simplify(x: str, n: str) -> bool:\n    def to_fraction(number: str) -> tuple:\n        numerator, denominator = map(int, number.split('/'))\n        return numerator, denominator\n\n    def is_whole_number(fraction: tuple) -> bool:\n        numerator, denominator = fraction\n        return (numerator % denominator) == 0\n\n    x_frac = to_fraction(x)\n    n_frac = to_fraction(n)\n\n    result_numerator = x_frac[0] * n_frac[0]\n    result_denominator = x_frac[1] * n_frac[1]\n\n    result_fraction = (result_numerator, result_denominator)\n\n    return is_whole_number(result_fraction)\n", "result": "passed", "passed": true}
{"task_id": "HumanEval/145", "completion": "def order_by_points(nums):\n    nums = sorted(nums, key=lambda x: (sum(int(digit) for digit in str(x)), nums.index(x)))\n    return nums", "result": "failed: invalid literal for int() with base 10: '-' (type: ValueError)", "passed": false}
{"task_id": "HumanEval/146", "completion": "def specialFilter(numbers):\n    THRESHOLD = 10\n    counter = 0\n\n    def is_odd(number):\n        first_digit = int(str(number)[0])\n        last_digit = int(str(number)[-1])\n        return first_digit % 2 != 0 and last_digit % 2 != 0\n\n    for number in numbers:\n        if number > THRESHOLD:\n            if is_odd(number):\n                counter += 1\n\n    return counter", "result": "passed", "passed": true}
{"task_id": "HumanEval/147", "completion": "def get_max_triples(n: int) -> int:\n    a = [i*i - i + 1 for i in range(1, n+1)]\n    \n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n    \n    return count\n", "result": "passed", "passed": true}
{"task_id": "HumanEval/148", "completion": "def bf(planet1: str, planet2: str) -> tuple:\n    planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    \n    start_index = planets.index(planet1)\n    end_index = planets.index(planet2)\n    \n    if start_index > end_index:\n        start_index, end_index = end_index, start_index\n    \n    sublist = planets[start_index+1:end_index]\n    sublist.sort(key=lambda x: planets.index(x))\n    \n    return tuple(sublist)", "result": "passed", "passed": true}
{"task_id": "HumanEval/149", "completion": "def sorted_list_sum(lst):\n    result_list = []\n    for word in lst:\n        if len(word) % 2 == 0:\n            result_list.append(word)\n    result_list.sort(key=lambda x: (len(x), x))\n    return result_list", "result": "passed", "passed": true}
{"task_id": "HumanEval/150", "completion": "def choose_value_based_on_prime_number(number: int, if_prime: int, if_not_prime: int) -> int:\n    if type(number) != int:\n        raise TypeError(\"Input 'number' should be an integer.\")\n    if type(if_prime) != int:\n        raise TypeError(\"Input 'if_prime' should be an integer.\")\n    if type(if_not_prime) != int:\n        raise TypeError(\"Input 'if_not_prime' should be an integer.\")\n    if number < 0 or if_prime < 0 or if_not_prime < 0:\n        raise ValueError(\"Input values should be non-negative.\")\n    \n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    \n    if is_prime(number):\n        return if_prime\n    else:\n        return if_not_prime\n", "result": "failed:  (type: AssertionError)", "passed": false}
{"task_id": "HumanEval/151", "completion": "from typing import List\n\ndef double_the_difference(lst: List[int]) -> int:\n    total = 0\n    for num in lst:\n        if isinstance(num, int) and num > 0 and num % 2 != 0:\n            total += num ** 2\n    return total", "result": "passed", "passed": true}
{"task_id": "HumanEval/152", "completion": "from typing import List\n\ndef compare(game: List[int], guess: List[int]) -> List[int]:\n    if len(game) != len(guess):\n        raise ValueError(\"The lengths of the game and guess lists must be the same.\")\n    \n    return [abs(g - s) if g != s else 0 for g, s in zip(guess, game)]\n", "result": "passed", "passed": true}
{"task_id": "HumanEval/153", "completion": "import re\nfrom typing import List\n\ndef strongest_extension(class_name: str, extensions: List[str]) -> str:\n    strongest_extension = \"\"\n    highest_strength = 0\n\n    for extension in extensions:\n        uppercase_count = len(re.findall(r'[A-Z]', extension))\n        lowercase_count = len(re.findall(r'[a-z]', extension))\n        strength = uppercase_count - lowercase_count\n\n        if strength > highest_strength:\n            strongest_extension = extension\n            highest_strength = strength\n\n    return f\"{class_name}.{strongest_extension}\"", "result": "failed:  (type: AssertionError)", "passed": false}
{"task_id": "HumanEval/154", "completion": "def cycpattern_check(a: str, b: str) -> bool:\n    \"\"\"Check if b is a rotation of a\"\"\"\n\n    len_a = len(a)\n    len_b = len(b)\n\n    for i in range(len_a):\n        # Check if b is a rotation of a\n        if a[i:] + a[:i] == b:\n            return True\n\n    return False", "result": "failed: test #1 (type: AssertionError)", "passed": false}
{"task_id": "HumanEval/155", "completion": "final_version = '''\nfrom typing import Tuple\n\ndef even_odd_count(num: int) -> Tuple[int, int]:\n    if num < 0:\n        raise ValueError(\"Input number cannot be negative\")\n\n    even_count = 0\n    odd_count = 0\n    num_str = str(num)\n\n    for digit in num_str:\n        if int(digit) % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n\n    return (even_count, odd_count)\n'''", "result": "failed:  (type: AssertionError)", "passed": false}
{"task_id": "HumanEval/156", "completion": "import re\n\ndef int_to_mini_roman(input_number: int) -> str:\n    if input_number < 1 or input_number > 1000:\n        raise ValueError(\"Input number is out of range. Please provide a number between 1 and 1000.\")\n\n    roman_values = {\n        1000: 'm', 900: 'cm', 500: 'd', 400: 'cd', \n        100: 'c', 90: 'xc', 50: 'l', 40: 'xl', \n        10: 'x', 9: 'ix', 5: 'v', 4: 'iv', 1: 'i'\n    }\n\n    roman_numeral = ''\n    for value, symbol in roman_values.items():\n        roman_numeral += symbol * (input_number // value)\n        input_number %= value\n\n    return roman_numeral.lower()", "result": "passed", "passed": true}
{"task_id": "HumanEval/157", "completion": "def right_angle_triangle(a: int, b: int, c: int) -> bool:\n    if a <= 0 or b <= 0 or c <= 0 or not isinstance(a, int) or not isinstance(b, int) or not isinstance(c, int):\n        return False\n    \n    if a + b <= c or b + c <= a or c + a <= b:\n        return False\n    \n    sorted_sides = sorted([a, b, c])\n    \n    if sorted_sides[0]**2 + sorted_sides[1]**2 == sorted_sides[2]**2:\n        if a == b == c:\n            return True\n        return True\n    \n    return False\n", "result": "passed", "passed": true}
{"task_id": "HumanEval/158", "completion": "from typing import List\n\ndef find_max(words: List[str]) -> str:\n    max_unique_count = 0\n    max_unique_word = \"\"\n    same_count_words = []\n\n    for word in words:\n        unique_count = len(set(word))\n\n        if unique_count > max_unique_count:\n            max_unique_count = unique_count\n            max_unique_word = word\n            same_count_words = []\n        elif unique_count == max_unique_count and word < max_unique_word:\n            max_unique_word = word\n        elif unique_count == max_unique_count:\n            same_count_words.append(word)\n\n    if same_count_words:\n        return min(same_count_words)\n    return max_unique_word\n", "result": "failed: t2 (type: AssertionError)", "passed": false}
{"task_id": "HumanEval/159", "completion": "from typing import List\n\ndef eat(carrots_eaten: int, carrots_needed: int, remaining_carrots: int) -> List[int]:\n    total_eaten = carrots_eaten + carrots_needed\n    carrots_left = remaining_carrots - carrots_needed\n    \n    if carrots_left < 0:\n        carrots_left = 0\n    \n    return list([total_eaten, carrots_left])\n", "result": "failed: Error (type: AssertionError)", "passed": false}
{"task_id": "HumanEval/160", "completion": "import math\nfrom typing import List, Union\n\n\nclass Operator(str):\n    \"\"\"\n    Enum to represent different operators.\n    \"\"\"\n\n    ADDITION = '+'\n    SUBTRACTION = '-'\n    MULTIPLICATION = '*'\n    DIVISION = '/'\n    EXPONENTIATION = '**'\n\n\ndef evaluate_expression(operators: List[Operator], operands: List[int]) -> int:\n    \"\"\"\n    Evaluates the given mathematical expression and returns the result.\n\n    Args:\n        operators (List[Operator]): List of operators in the expression.\n        operands (List[int]): List of operands in the expression.\n\n    Returns:\n        int: Result of the expression.\n\n    Raises:\n        ValueError: If an invalid operator is encountered.\n\n    \"\"\"\n    if len(operators) != len(operands) - 1:\n        raise ValueError(\"Invalid expression: Length of operators list should be one less than operands list\")\n\n    result = operands[0]\n    for operator, operand in zip(operators, operands[1:]):\n        if operator == Operator.ADDITION:\n            result += operand\n        elif operator == Operator.SUBTRACTION:\n            result -= operand\n        elif operator == Operator.MULTIPLICATION:\n            result *= operand\n        elif operator == Operator.DIVISION:\n            if operand == 0:\n                raise ValueError(\"Invalid expression: Division by zero\")\n            result /= operand\n        elif operator == Operator.EXPONENTIATION:\n            result **= operand\n        else:\n            raise ValueError(f\"Invalid operator: {operator}\")\n\n    return math.floor(result)", "result": "failed:  (type: AssertionError)", "passed": false}
{"task_id": "HumanEval/161", "completion": "def solve(s):\n    if s is None or len(s) == 0:\n        return \"\"\n\n    modified_str = \"\"\n    is_reversed = True\n\n    for c in s:\n        if c.isalpha():\n            modified_c = c.swapcase()\n            modified_str += modified_c\n        else:\n            modified_str += c\n\n        if c.isalpha():\n            is_reversed = False\n\n    if is_reversed:\n        modified_str = modified_str[::-1]\n\n    return modified_str", "result": "passed", "passed": true}
{"task_id": "HumanEval/162", "completion": "import hashlib\nfrom typing import Optional\n\ndef string_to_md5(text: Optional[str]) -> Optional[str]:\n    if text is None:\n        return None\n    return hashlib.md5(text.encode()).hexdigest()", "result": "failed:  (type: AssertionError)", "passed": false}
{"task_id": "HumanEval/163", "completion": "def generate_integers(a, b):\n    even_digits = []\n    for num in range(a, b+1):\n        if str(num)[-1] in ['0', '2', '4', '6', '8']:\n            even_digits.append(num)\n    return sorted(even_digits)", "result": "failed: Test 1 (type: AssertionError)", "passed": false}
