{"task_id": "HumanEval/0", "completion": "\nfrom typing import List\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Check if there are two elements in the given list that have a difference\n    less than the given threshold.\n    \n    Args:\n        numbers (List[float]): A list of numbers.\n        threshold (float): The maximum difference allowed between two elements.\n    \n    Returns:\n        bool: True if there are two close elements, False otherwise.\n    \"\"\"\n    try:\n        n = len(numbers)\n        for first_index in range(n):\n            for second_index in range(first_index+1, n):\n                if abs(numbers[first_index] - numbers[second_index]) < threshold:\n                    return True\n        return False\n    except TypeError:\n        return False\n\n"}
{"task_id": "HumanEval/1", "completion": "\nfrom typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    paren_string = paren_string.replace(\" \", \"\")\n    \n    result = []\n    stack = []\n    group_start_index = 0\n    \n    for i, char in enumerate(paren_string):\n        if char == \"(\":\n            stack.append(char)\n        elif char == \")\":\n            stack.pop()\n            \n            if not stack:\n                result.append(paren_string[group_start_index: i + 1])\n                group_start_index = i + 1\n    \n    return result\n"}
{"task_id": "HumanEval/2", "completion": "\ndef truncate_number(number: float) -> float:\n    \"\"\"\n    Truncates the decimal part of a given number and returns it.\n\n    Args:\n        number (float): The number to truncate.\n\n    Returns:\n        float: The truncated decimal part of the number.\n    \"\"\"\n    # Validate input\n    if not isinstance(number, float):\n        raise ValueError(\"Input must be a floating-point number\")\n\n    # Get the decimal part of the number\n    decimal_part = number - int(number)\n\n    # Return the decimal part\n    return decimal_part\n"}
{"task_id": "HumanEval/3", "completion": "from typing import List\n\ndef below_zero(transaction_list: List[int]) -> bool:\n    balance = 0\n    for transaction in transaction_list:\n        balance += transaction\n        if balance < 0:\n            return True\n    return False"}
{"task_id": "HumanEval/4", "completion": "from typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    if len(numbers) == 0:\n        return 0.0\n    \n    mean: float = sum(numbers) / len(numbers)\n    total_deviation: float = sum(abs(x - mean) for x in numbers)\n    mean_absolute_deviation: float = total_deviation / len(numbers)\n    \n    return mean_absolute_deviation"}
{"task_id": "HumanEval/5", "completion": "from typing import List\n\ndef validate_input(numbers: List[int], delimiter: int) -> None:\n    if not isinstance(numbers, list):\n        raise TypeError(\"'numbers' should be a list\")\n    if not isinstance(delimiter, int):\n        raise TypeError(\"'delimiter' should be an integer\")\n\ndef intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    validate_input(numbers, delimiter)\n    result = []\n    for i, num in enumerate(numbers):\n        result.append(num)\n        if i < len(numbers) - 1:\n            result.append(delimiter)\n    return result"}
{"task_id": "HumanEval/6", "completion": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    result = []\n    groups = paren_string.split()\n    for group in groups:\n        max_depth = 0 \n        current_depth = 0 \n        for char in group:\n            if char == \"(\":\n                current_depth += 1 \n                if current_depth > max_depth:\n                    max_depth = current_depth \n            elif char == \")\":\n                current_depth -= 1 \n        result.append(max_depth)\n    return result"}
{"task_id": "HumanEval/7", "completion": "\nfrom typing import List\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    filtered_strings = []\n    for string in strings:\n        if substring in string:\n            filtered_strings.append(string)\n    return filtered_strings\n"}
{"task_id": "HumanEval/8", "completion": "from typing import List, Tuple\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    sum_total = 0\n    product_total = 1\n\n    for num in numbers:\n        sum_total += num\n        product_total *= num\n\n    return sum_total, product_total"}
{"task_id": "HumanEval/9", "completion": "from typing import List\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    rolling_max_list = []\n    if numbers:\n        rolling_max_list.append(numbers[0])\n        for i in range(1, len(numbers)):\n            max_num = max(numbers[i], rolling_max_list[i-1])\n            rolling_max_list.append(max_num)\n    return rolling_max_list"}
{"task_id": "HumanEval/10", "completion": "\ndef is_palindrome(string: str) -> bool:\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    for i in range(len(string), 0, -1):\n        if string[:i] == string[:i][::-1]:\n            return string + string[:i-1][::-1]\n    return \"\"\n"}
{"task_id": "HumanEval/11", "completion": "from typing import List\n\ndef string_xor_operation(a: str, b: str) -> str:\n    if len(a) != len(b):\n        raise ValueError(\"Input strings must have the same length\")\n    \n    for char in a + b:\n        if char not in ['0', '1']:\n            raise ValueError(\"Input strings must only contain 0s and 1s\")\n    \n    result = ''\n    for i in range(len(a)):\n        if a[i] == b[i]:\n            result += '0'\n        else:\n            result += '1'\n    \n    return result"}
{"task_id": "HumanEval/12", "completion": "from typing import List, Optional\n\ndef longest(strings: List[str]) -> Optional[str]:\n    if not strings:\n        return None\n    \n    longest_string = strings[0]\n    for string in strings:\n        if len(string) > len(longest_string):\n            longest_string = string\n    \n    return longest_string"}
{"task_id": "HumanEval/13", "completion": "import math\n\ndef greatest_common_divisor(num1: int, num2: int) -> int:\n    if not isinstance(num1, int) or not isinstance(num2, int):\n        raise ValueError(\"Both inputs must be integers\")\n    \n    return math.gcd(num1, num2)"}
{"task_id": "HumanEval/14", "completion": "from typing import List\n\ndef all_prefixes(string: str) -> List[str]:\n    prefixes = []\n    for i in range(len(string)):\n        prefixes.append(string[:i+1])\n    return prefixes"}
{"task_id": "HumanEval/15", "completion": "def string_sequence(n: int) -> str:\n    try:\n        if not isinstance(n, int):\n            raise TypeError(\"Input should be an integer\")\n        \n        return ' '.join(str(i) for i in range(n + 1))\n    except Exception as e:\n        return str(e)"}
{"task_id": "HumanEval/16", "completion": "def count_distinct_characters(input_string: str) -> int:\n    input_string = input_string.lower()\n    distinct_characters = set()\n    for char in input_string:\n        distinct_characters.add(char)\n    return len(distinct_characters)"}
{"task_id": "HumanEval/17", "completion": "from typing import List\n\ndef parse_music(music_string: str) -> List[int]:\n    note_durations = {'o': 4, 'o|': 2, '.|': 1}\n\n    beats = []\n    current_note = \"\"\n    for char in music_string:\n        if char == 'o':\n            if current_note in note_durations:\n                beats.append(note_durations[current_note])\n            current_note = 'o'\n        elif char == '|':\n            current_note += '|'\n        elif char == '.':\n            current_note += '.'\n\n    if current_note in note_durations:\n        beats.append(note_durations[current_note])\n\n    return beats\n"}
{"task_id": "HumanEval/18", "completion": "def how_many_times(string: str, substring: str) -> int:\n    substring_length = len(substring)\n    count = 0\n\n    for i in range(len(string) - substring_length + 1):\n        sub = string[i:i+substring_length]\n        if substring in sub:\n            count += 1\n\n    return count"}
{"task_id": "HumanEval/19", "completion": "from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    number_mapping = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    \n    number_list = numbers.split()\n\n    if not number_list:\n        return \"\"\n    \n    sorted_number_list = sorted(number_list, key=lambda x: number_mapping[x])\n    \n    sorted_numbers = ' '.join(sorted_number_list)\n    return sorted_numbers"}
{"task_id": "HumanEval/20", "completion": "from typing import List, Tuple\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    numbers.sort()  \n    \n    min_diff = float('inf')\n    closest_values = ()\n    \n    for i in range(len(numbers)-1):\n        diff = numbers[i+1] - numbers[i]\n        \n        if diff < min_diff:\n            min_diff = diff\n            closest_values = (numbers[i], numbers[i+1])\n    \n    return closest_values"}
